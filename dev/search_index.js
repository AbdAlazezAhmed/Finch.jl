var documenterSearchIndex = {"docs":
[{"location":"fibers/","page":"Array Formats","title":"Array Formats","text":"CurrentModule = Finch","category":"page"},{"location":"fibers/#Level-Formats","page":"Array Formats","title":"Level Formats","text":"","category":"section"},{"location":"fibers/","page":"Array Formats","title":"Array Formats","text":"Finch implements a flexible array datastructure called a fiber. Fibers represent arrays as rooted trees, where the child of each node is selected by an array index. Finch is column major, so in an expression A[i_1, ..., i_N], the rightmost dimension i_N corresponds to the root level of the tree, and the leftmost dimension i_1 corresponds to the leaf level. When the array is dense, the leftmost dimension has stride 1. We can convert the matrix A to a fiber with the @fiber constructor:","category":"page"},{"location":"fibers/","page":"Array Formats","title":"Array Formats","text":"(Image: Example Matrix)","category":"page"},{"location":"fibers/","page":"Array Formats","title":"Array Formats","text":"julia> A = [0.0 0.0 4.4; 1.1 0.0 0.0; 2.2 0.0 5.5; 3.3 0.0 0.0]\n4×3 Matrix{Float64}:\n 0.0  0.0  4.4\n 1.1  0.0  0.0\n 2.2  0.0  5.5\n 3.3  0.0  0.0\njulia> A_fbr = @fiber(d(d(e(0.0))), A)\nDense [:,1:3]\n├─[:,1]: Dense [1:4]\n│ ├─[1]: 0.0\n│ ├─[2]: 1.1\n│ ├─[3]: 2.2\n│ ├─[4]: 3.3\n├─[:,2]: Dense [1:4]\n│ ├─[1]: 0.0\n│ ├─[2]: 0.0\n│ ├─[3]: 0.0\n│ ├─[4]: 0.0\n├─[:,3]: Dense [1:4]\n│ ├─[1]: 4.4\n│ ├─[2]: 0.0\n│ ├─[3]: 5.5\n│ ├─[4]: 0.0","category":"page"},{"location":"fibers/","page":"Array Formats","title":"Array Formats","text":"We refer to a node in the tree as a subfiber. All of the nodes at the same level are stored in the same datastructure, and disambiguated by an integer position.  In the above example, there are three levels: The rootmost level contains only one fiber, the root. The middle level has 3 subfibers, one for each column. The leafmost level has 12 subfibers, one for each element of the array.  For example, the first level is A_fbr.lvl, and we can represent it's third position as SubFiber(A_fbr.lvl.lvl, 3). The second level is A_fbr.lvl.lvl, and we can access it's 9th position as SubFiber(A_fbr.lvl.lvl.lvl, 9). For instructional purposes, you can use parentheses to call a fiber on an index to select among children of a fiber.","category":"page"},{"location":"fibers/","page":"Array Formats","title":"Array Formats","text":"julia> Finch.SubFiber(A_fbr.lvl.lvl, 3)\nDense [1:4]\n├─[1]: 4.4\n├─[2]: 0.0\n├─[3]: 5.5\n├─[4]: 0.0\n\njulia> A_fbr[:, 3]\nDense [1:4]\n├─[1]: 4.4\n├─[2]: 0.0\n├─[3]: 5.5\n├─[4]: 0.0\n\njulia> A_fbr(3)\nDense [1:4]\n├─[1]: 4.4\n├─[2]: 0.0\n├─[3]: 5.5\n├─[4]: 0.0\n\njulia> Finch.SubFiber(A_fbr.lvl.lvl.lvl, 9)\n4.4\n\njulia> A_fbr[1, 3]\n4.4\n\njulia> A_fbr(3)(1)\n4.4\n","category":"page"},{"location":"fibers/","page":"Array Formats","title":"Array Formats","text":"When we print the tree in text, positions are numbered from top to bottom. However, if we visualize our tree with the root at the top, positions range from left to right:","category":"page"},{"location":"fibers/","page":"Array Formats","title":"Array Formats","text":"(Image: Dense Format Index Tree)","category":"page"},{"location":"fibers/","page":"Array Formats","title":"Array Formats","text":"Because our array is sparse, (mostly zero, or another fill value), it would be more efficient to store only the nonzero values. In Finch, each level is represented with a different format. A sparse level only stores non-fill values. This time, we'll use a fiber constructor with sl (for \"SparseList of nonzeros\") instead of d (for \"Dense\"):","category":"page"},{"location":"fibers/","page":"Array Formats","title":"Array Formats","text":"julia> A_fbr = @fiber(d(sl(e(0.0))), A)\nDense [:,1:3]\n├─[:,1]: SparseList (0.0) [1:4]\n│ ├─[2]: 1.1\n│ ├─[3]: 2.2\n│ ├─[4]: 3.3\n├─[:,2]: SparseList (0.0) [1:4]\n├─[:,3]: SparseList (0.0) [1:4]\n│ ├─[1]: 4.4\n│ ├─[3]: 5.5","category":"page"},{"location":"fibers/","page":"Array Formats","title":"Array Formats","text":"(Image: CSC Format Index Tree)","category":"page"},{"location":"fibers/","page":"Array Formats","title":"Array Formats","text":"Our d(sl(e(0.0))) format is also known as \"CSC\" and is equivalent to SparseMatrixCSC. The fiber! function will perform a zero-cost copy between Finch fibers and sparse matrices, when available.  CSC is an excellent general-purpose representation when we expect most of the columns to have a few nonzeros. However, when most of the columns are entirely fill (a situation known as hypersparsity), it is better to compress the root level as well:","category":"page"},{"location":"fibers/","page":"Array Formats","title":"Array Formats","text":"julia> A_fbr = @fiber(sl(sl(e(0.0))), A)\nSparseList (0.0) [:,1:3]\n├─[:,1]: SparseList (0.0) [1:4]\n│ ├─[2]: 1.1\n│ ├─[3]: 2.2\n│ ├─[4]: 3.3\n├─[:,3]: SparseList (0.0) [1:4]\n│ ├─[1]: 4.4\n│ ├─[3]: 5.5","category":"page"},{"location":"fibers/","page":"Array Formats","title":"Array Formats","text":"(Image: DCSC Format Index Tree)","category":"page"},{"location":"fibers/","page":"Array Formats","title":"Array Formats","text":"Here we see that the entirely zero column has also been compressed. The sl(sl(e(0.0))) format is also known as \"DCSC\".","category":"page"},{"location":"fibers/","page":"Array Formats","title":"Array Formats","text":"The \"COO\" (or \"Coordinate\") format is often used in practice for ease of interchange between libraries. In an N-dimensional array A, COO stores N lists of indices I_1, ..., I_N where A[I_1[p], ..., I_N[p]] is the p^th stored value in column-major numbering. In Finch, COO is represented as a multi-index level, which can handle more than one index at once. We use curly brackets to declare the number of indices handled by the level:","category":"page"},{"location":"fibers/","page":"Array Formats","title":"Array Formats","text":"julia> A_fbr = @fiber(sc{2}(e(0.0)), A)\nSparseCOO (0.0) [1:4,1:3]\n├─├─[2, 1]: 1.1\n├─├─[3, 1]: 2.2\n├─├─[4, 1]: 3.3\n├─├─[1, 3]: 4.4\n├─├─[3, 3]: 5.5","category":"page"},{"location":"fibers/","page":"Array Formats","title":"Array Formats","text":"(Image: COO Format Index Tree)","category":"page"},{"location":"fibers/","page":"Array Formats","title":"Array Formats","text":"The COO format is compact and straightforward, but doesn't support random access. For random access, one should use the SparseHash format. A full listing of supported formats is described below:","category":"page"},{"location":"fibers/#Public-Functions","page":"Array Formats","title":"Public Functions","text":"","category":"section"},{"location":"fibers/#Fiber-Constructors","page":"Array Formats","title":"Fiber Constructors","text":"","category":"section"},{"location":"fibers/","page":"Array Formats","title":"Array Formats","text":"@fiber\nfiber\nfiber!","category":"page"},{"location":"fibers/#Finch.@fiber","page":"Array Formats","title":"Finch.@fiber","text":"@fiber ctr [arg]\n\nConstruct a fiber using abbreviated level constructor names. To override abbreviations, expressions may be interpolated with $. For example, Fiber(DenseLevel(SparseListLevel(Element(0.0)))) can also be constructed as @fiber(sl(d(e(0.0)))). Consult the documentation for the helper function f_code for a full listing of level format codes.\n\nOptionally, an argument may be specified to copy into the fiber. This expression allocates. Use fiber(arg) for a zero-cost copy, if available.\n\n\n\n\n\n","category":"macro"},{"location":"fibers/#Finch.fiber","page":"Array Formats","title":"Finch.fiber","text":"fiber(arr, default = zero(eltype(arr)))\n\nCopies an array-like object arr into a corresponding, similar Fiber datastructure. default is the default value to use for initialization and sparse compression.\n\nSee also: fiber!\n\nExamples\n\njulia> println(summary(fiber(sparse([1 0; 0 1]))))\n2×2 @fiber(d(sl(e(0))))\n\njulia> println(summary(fiber(ones(3, 2, 4))))\n3×2×4 @fiber(d(d(d(e(0.0)))))\n\n\n\n\n\n","category":"function"},{"location":"fibers/#Finch.fiber!","page":"Array Formats","title":"Finch.fiber!","text":"fiber!(arr, default = zero(eltype(arr)))\n\nLike fiber, copies an array-like object arr into a corresponding, similar Fiber datastructure. However, fiber! reuses memory whenever possible, meaning arr may be rendered unusable.\n\n\n\n\n\n","category":"function"},{"location":"fibers/#Level-Constructors","page":"Array Formats","title":"Level Constructors","text":"","category":"section"},{"location":"fibers/","page":"Array Formats","title":"Array Formats","text":"DenseLevel\nElementLevel\nSparseListLevel\nSparseCOOLevel\nSparseHashLevel","category":"page"},{"location":"fibers/#Finch.DenseLevel","page":"Array Formats","title":"Finch.DenseLevel","text":"DenseLevel{[Ti=Int]}(lvl, [dim])\n\nA subfiber of a dense level is an array which stores every slice A[:, ..., :, i] as a distinct subfiber in lvl. Optionally, dim is the size of the last dimension. Ti is the type of the indices used to index the level.\n\nIn the @fiber constructor, d is an alias for DenseLevel.\n\njulia> ndims(@fiber(d(e(0.0))))\n1\n\njulia> ndims(@fiber(d(d(e(0.0)))))\n2\n\njulia> @fiber(d(d(e(0.0))), [1 2; 3 4])\nDense [:,1:2]\n├─[:,1]: Dense [1:2]\n│ ├─[1]: 1.0\n│ ├─[2]: 3.0\n├─[:,2]: Dense [1:2]\n│ ├─[1]: 2.0\n│ ├─[2]: 4.0\n\n\n\n\n\n","category":"type"},{"location":"fibers/#Finch.ElementLevel","page":"Array Formats","title":"Finch.ElementLevel","text":"ElementLevel{D, [Tv]}()\n\nA subfiber of an element level is a scalar of type Tv, initialized to D. D may optionally be given as the first argument.\n\nIn the @fiber constructor, e is an alias for ElementLevel.\n\njulia> @fiber(d(e(0.0)), [1, 2, 3])\nDense [1:3]\n├─[1]: 1.0\n├─[2]: 2.0\n├─[3]: 3.0\n\n\n\n\n\n","category":"type"},{"location":"fibers/#Finch.SparseListLevel","page":"Array Formats","title":"Finch.SparseListLevel","text":"SparseListLevel{[Ti=Int], [Tp=Int]}(lvl, [dim])\n\nA subfiber of a sparse level does not need to represent slices A[:, ..., :, i] which are entirely default. Instead, only potentially non-default slices are stored as subfibers in lvl.  A sorted list is used to record which slices are stored. Optionally, dim is the size of the last dimension.\n\nTi is the type of the last fiber index, and Tp is the type used for positions in the level.\n\nIn the @fiber constructor, sl is an alias for SparseListLevel.\n\njulia> @fiber(d(sl(e(0.0))), [10 0 20; 30 0 0; 0 0 40])\nDense [:,1:3]\n├─[:,1]: SparseList (0.0) [1:3]\n│ ├─[1]: 10.0\n│ ├─[2]: 30.0\n├─[:,2]: SparseList (0.0) [1:3]\n├─[:,3]: SparseList (0.0) [1:3]\n│ ├─[1]: 20.0\n│ ├─[3]: 40.0\n\njulia> @fiber(sl(sl(e(0.0))), [10 0 20; 30 0 0; 0 0 40])\nSparseList (0.0) [:,1:3]\n├─[:,1]: SparseList (0.0) [1:3]\n│ ├─[1]: 10.0\n│ ├─[2]: 30.0\n├─[:,3]: SparseList (0.0) [1:3]\n│ ├─[1]: 20.0\n│ ├─[3]: 40.0\n\n\n\n\n\n\n","category":"type"},{"location":"fibers/#Finch.SparseCOOLevel","page":"Array Formats","title":"Finch.SparseCOOLevel","text":"SparseCOOLevel{[N], [Ti=Tuple{Int...}], [Tp=Int]}(lvl, [dims])\n\nA subfiber of a sparse level does not need to represent slices which are entirely default. Instead, only potentially non-default slices are stored as subfibers in lvl. The sparse coo level corresponds to N indices in the subfiber, so fibers in the sublevel are the slices A[:, ..., :, i_1, ..., i_n].  A set of N lists (one for each index) are used to record which slices are stored. The coordinates (sets of N indices) are sorted in column major order.  Optionally, dims are the sizes of the last dimensions.\n\nTi is the type of the last N fiber indices, and Tp is the type used for positions in the level.\n\nIn the @fiber constructor, sh is an alias for SparseCOOLevel.\n\njulia> @fiber(d(sc{1}(e(0.0))), [10 0 20; 30 0 0; 0 0 40])\nDense [:,1:3]\n├─[:,1]: SparseCOO (0.0) [1:3]\n│ ├─[1]: 10.0\n│ ├─[2]: 30.0\n├─[:,2]: SparseCOO (0.0) [1:3]\n├─[:,3]: SparseCOO (0.0) [1:3]\n│ ├─[1]: 20.0\n│ ├─[3]: 40.0\n\njulia> @fiber(sc{2}(e(0.0)), [10 0 20; 30 0 0; 0 0 40])\nSparseCOO (0.0) [1:3,1:3]\n├─├─[1, 1]: 10.0\n├─├─[2, 1]: 30.0\n├─├─[1, 3]: 20.0\n├─├─[3, 3]: 40.0\n\n\n\n\n\n","category":"type"},{"location":"fibers/#Finch.SparseHashLevel","page":"Array Formats","title":"Finch.SparseHashLevel","text":"SparseHashLevel{[N], [Ti=Tuple{Int...}], [Tp=Int]}(lvl, [dims])\n\nA subfiber of a sparse level does not need to represent slices which are entirely default. Instead, only potentially non-default slices are stored as subfibers in lvl. The sparse hash level corresponds to N indices in the subfiber, so fibers in the sublevel are the slices A[:, ..., :, i_1, ..., i_n].  A hash table is used to record which slices are stored. Optionally, dims are the sizes of the last dimensions.\n\nTi is the type of the last N fiber indices, and Tp is the type used for positions in the level.\n\nIn the @fiber constructor, sh is an alias for SparseHashLevel.\n\njulia> @fiber(d(sh{1}(e(0.0))), [10 0 20; 30 0 0; 0 0 40])\nDense [:,1:3]\n├─[:,1]: SparseHash (0.0) [1:3]\n│ ├─[1]: 10.0\n│ ├─[2]: 30.0\n├─[:,2]: SparseHash (0.0) [1:3]\n├─[:,3]: SparseHash (0.0) [1:3]\n│ ├─[1]: 20.0\n│ ├─[3]: 40.0\n\njulia> @fiber(sh{2}(e(0.0)), [10 0 20; 30 0 0; 0 0 40])\nSparseHash (0.0) [1:3,1:3]\n├─├─[1, 1]: 10.0\n├─├─[2, 1]: 30.0\n├─├─[1, 3]: 20.0\n├─├─[3, 3]: 40.0\n\n\n\n\n\n","category":"type"},{"location":"fibers/#Index-Compatibility","page":"Array Formats","title":"0-Index Compatibility","text":"","category":"section"},{"location":"fibers/","page":"Array Formats","title":"Array Formats","text":"Julia, Matlab, etc. index arrays starting at 1. C, python, etc. index starting at 0. In a dense array, we can simply subtract one from the index, and in fact, this is what Julia will does under the hood when you pass a vector between C to Julia. ","category":"page"},{"location":"fibers/","page":"Array Formats","title":"Array Formats","text":"However, for sparse array formats, it's not just a matter of subtracting one from the index, as the internal lists of indices, positions, etc all start from zero as well. To remedy the situation, Finch defines a handy zero-indexed integer type called CIndex. The internal representation of CIndex is one less than the value it represents, and we can use CIndex as the index or position type of a Finch array to represent arrays in other languages.","category":"page"},{"location":"fibers/","page":"Array Formats","title":"Array Formats","text":"For example, if idx_c, ptr_c, and val_c are the internal arrays of a CSC matrix in a zero-indexed language, we can represent that matrix as a one-indexed Finch array without copying by calling","category":"page"},{"location":"fibers/","page":"Array Formats","title":"Array Formats","text":"DocTestSetup = quote\n    using Finch\n    using Finch: Cindex\nend","category":"page"},{"location":"fibers/","page":"Array Formats","title":"Array Formats","text":"julia> m = 4; n = 3; ptr_c = [0, 3, 3, 5]; idx_c = [1, 2, 3, 0, 2]; val_c = [1.1, 2.2, 3.3, 4.4, 5.5];\n\njulia> ptr_jl = unsafe_wrap(Array, reinterpret(Ptr{Cindex{Int}}, pointer(ptr_c)), length(ptr_c); own = false)\n4-element Vector{Cindex{Int64}}:\n Cindex{Int64}(0)\n Cindex{Int64}(3)\n Cindex{Int64}(3)\n Cindex{Int64}(5)\njulia> idx_jl = unsafe_wrap(Array, reinterpret(Ptr{Cindex{Int}}, pointer(idx_c)), length(idx_c); own = false)\n5-element Vector{Cindex{Int64}}:\n Cindex{Int64}(1)\n Cindex{Int64}(2)\n Cindex{Int64}(3)\n Cindex{Int64}(0)\n Cindex{Int64}(2)\njulia> A = Fiber(Dense(SparseList{Cindex{Int}, Cindex{Int}}(Element{0.0, Float64}(val_c), m, ptr_jl, idx_jl), n))\nDense [:,1:3]\n├─[:,1]: SparseList (0.0) [1:Cindex{Int64}(3)]\n│ ├─[Cindex{Int64}(1)]: 1.1\n│ ├─[Cindex{Int64}(2)]: 2.2\n│ ├─[Cindex{Int64}(3)]: 3.3\n├─[:,2]: SparseList (0.0) [1:Cindex{Int64}(3)]\n├─[:,3]: SparseList (0.0) [1:Cindex{Int64}(3)]\n│ ├─[Cindex{Int64}(0)]: 4.4\n│ ├─[Cindex{Int64}(2)]: 5.5","category":"page"},{"location":"fibers/","page":"Array Formats","title":"Array Formats","text":"We can also convert between representations by by copying to or from Cindex fibers.","category":"page"},{"location":"embed/","page":"Embedding","title":"Embedding","text":"CurrentModule = Finch","category":"page"},{"location":"embed/#Public-Functions","page":"Embedding","title":"Public Functions","text":"","category":"section"},{"location":"embed/","page":"Embedding","title":"Embedding","text":"Finch.h.FINCH_SCOPE\nFinch.h.finch_escape\nFinch.h.finch_eval\nFinch.h.finch_consume_vector\nFinch.h.finch_free\nFinch.h.finch_mirror_vector\nFinch.h.finch_initialize\nFinch.h.finch_root\nFinch.h.finch_exec\nFinch.h.finch_T\nFinch.h.finch_call\nFinch.h.finch_finalize","category":"page"},{"location":"embed/#Finch.h.FINCH_SCOPE","page":"Embedding","title":"Finch.h.FINCH_SCOPE","text":"FINCH_SCOPE([stmt])\n\nExecute the statement stmt in a new finch scope. All finch objects allocated within this scope will be freed when the scope is closed, unless passed to finch_escape to pass them to the parent scope. The user must not use return or break to leave stmt.\n\n\n\n\n\n","category":"function"},{"location":"embed/#Finch.h.finch_escape","page":"Embedding","title":"Finch.h.finch_escape","text":"jl_value_t* finch_escape(jl_value_t* var)\n\nRemoves var from the current scope and registers it with the parent scope. This meansvar will not be freed when the current scope is closed.\n\n\n\n\n\n","category":"function"},{"location":"embed/#Finch.h.finch_eval","page":"Embedding","title":"Finch.h.finch_eval","text":"jl_value_t* finch_eval(const char* proc)\n\nEvaluate the Julia code represented by the string proc at global scope in the Main module.\n\n\n\n\n\n","category":"function"},{"location":"embed/#Finch.h.finch_consume_vector","page":"Embedding","title":"Finch.h.finch_consume_vector","text":"jl_value_t* finch_consume_vector(jl_datatype_t* type, void* ptr, int len);\n\nCreate a Julia array with elements of datatype type from the pointer ptr. The array will be of length len, no copying will be performed, and Finch may call free(ptr).\n\n\n\n\n\n","category":"function"},{"location":"embed/#Finch.h.finch_free","page":"Embedding","title":"Finch.h.finch_free","text":"void finch_free(jl_value_t* var)\n\nUnregister the Finch-tracked object var within the current scope to allow the garbage collector to free memory. This method should be avoided in favor of using FINCH_SCOPE to limit the lifetime of objects.\n\n\n\n\n\n","category":"function"},{"location":"embed/#Finch.h.finch_mirror_vector","page":"Embedding","title":"Finch.h.finch_mirror_vector","text":"jl_value_t* finch_mirror_vector(jl_datatype_t* type, void* ptr, int len);\n\nCreate a Julia array with elements of datatype type from the pointer ptr. The array will be of length len, no copying will be performed, and Finch may not call free(ptr).\n\n\n\n\n\n","category":"function"},{"location":"embed/#Finch.h.finch_initialize","page":"Embedding","title":"Finch.h.finch_initialize","text":"void finch_initialize()\n\nInitialize Finch. Should be called only once before any other finch calls, from the executable.\n\n\n\n\n\n","category":"function"},{"location":"embed/#Finch.h.finch_root","page":"Embedding","title":"Finch.h.finch_root","text":"jl_value_t* finch_root(jl_value_t* var)\n\nRegister the Julia-allocated object var with Finch on the current scope to avoid garbage collecting it.\n\n\n\n\n\n","category":"function"},{"location":"embed/#Finch.h.finch_exec","page":"Embedding","title":"Finch.h.finch_exec","text":"jl_value_t* finch_exec(const char* proc, jl_value_t* args...)\n\nEvaluate the Julia code represented by the string proc at local scope in the Main module.  proc can optionally contain format specifiers to interpolate julia arguments.  Format specifiers should be either %s for a julia input or %% for a literal % character. For example,\n\n    finch_exec(\"%s + %s\", x, y)\n\nshould evaluate to x + y\n\nfinch_exec caches inputs by their string to avoid repeated compilation.\n\n\n\n\n\n","category":"function"},{"location":"embed/#Finch.h.finch_T","page":"Embedding","title":"Finch.h.finch_T","text":"void finch_[T](S x);\n\nCreate a Julia object of type T from corresponding C object x of type S.\n\n\n\n\n\n","category":"function"},{"location":"embed/#Finch.h.finch_call","page":"Embedding","title":"Finch.h.finch_call","text":"jl_value_t* finch_call(jl_value_t* f, jl_value_t* args...)\n\nCall the Julia function f on the arguments args and return the result. This is a macro that counts the number of arguments.\n\n\n\n\n\n","category":"function"},{"location":"embed/#Finch.h.finch_finalize","page":"Embedding","title":"Finch.h.finch_finalize","text":"void finch_finalize()\n\nFinalize Finch. Should be called at the end of the program to allow Finch to cleanup.\n\n\n\n\n\n","category":"function"},{"location":"development/","page":"Development Guide","title":"Development Guide","text":"CurrentModule = Finch","category":"page"},{"location":"development/#Development-Guide","page":"Development Guide","title":"Development Guide","text":"","category":"section"},{"location":"development/","page":"Development Guide","title":"Development Guide","text":"We welcome contributions to Finch! Before you start, please double-check in a Github issue that there is interest from a contributor in moderating your potential pull request.","category":"page"},{"location":"development/#Testing","page":"Development Guide","title":"Testing","text":"","category":"section"},{"location":"development/","page":"Development Guide","title":"Development Guide","text":"All pull requests should pass continuous integration testing before merging. For more information about running tests (including filtering test suites or updating the reference output), run the test script directly:","category":"page"},{"location":"development/","page":"Development Guide","title":"Development Guide","text":"julia tests/runtests.jl --help","category":"page"},{"location":"development/#Finch-Compilation-Pipeline","page":"Development Guide","title":"Finch Compilation Pipeline","text":"","category":"section"},{"location":"development/#Program-Instances","page":"Development Guide","title":"Program Instances","text":"","category":"section"},{"location":"development/","page":"Development Guide","title":"Development Guide","text":"Finch relies heavily on Julia's metaprogramming capabilities ( macros and generated functions in particular) to produce code. To review briefly, a macro allows us to inspect the syntax of it's arguments and generate replacement syntax. A generated function allows us to inspect the type of the function arguments and produce code for a function body.","category":"page"},{"location":"development/","page":"Development Guide","title":"Development Guide","text":"In normal Finch usage, we might call Finch as follows:","category":"page"},{"location":"development/","page":"Development Guide","title":"Development Guide","text":"julia> C = @fiber(sl(e(0)));\n\njulia> A = @fiber(sl(e(0)), [0, 2, 0, 0, 3]);\n\njulia> B = @fiber(d(e(0)), [11, 12, 13, 14, 15]);\n\njulia> @finch (C .= 0; @loop i C[i] = A[i] * B[i]);\n\njulia> C\nSparseList (0) [1:5]\n├─[2]: 24\n├─[5]: 45","category":"page"},{"location":"development/","page":"Development Guide","title":"Development Guide","text":"The @macroexpand macro allows us to see the result of applying a macro. Let's examine what happens when we use the @finch macro (we've stripped line numbers from the result to clean it up):","category":"page"},{"location":"development/","page":"Development Guide","title":"Development Guide","text":"julia> (@macroexpand @finch (C .= 0; @loop i C[i] = A[i] * B[i])) |> Finch.striplines |> Finch.regensym\nquote\n    _res_1 = (Finch.execute)((Finch.FinchNotation.sequence_instance)((Finch.FinchNotation.declare_instance)((Finch.FinchNotation.variable_instance)(:C, (Finch.FinchNotation.finch_leaf_instance)(C)), literal_instance(0)), begin\n                    let i = index_instance(:i)\n                        (Finch.FinchNotation.loop_instance)(i, (Finch.FinchNotation.assign_instance)((Finch.FinchNotation.access_instance)((Finch.FinchNotation.variable_instance)(:C, (Finch.FinchNotation.finch_leaf_instance)(C)), (Finch.FinchNotation.updater_instance)((Finch.FinchNotation.create_instance)()), (Finch.FinchNotation.variable_instance)(:i, (Finch.FinchNotation.finch_leaf_instance)(i))), literal_instance(right), (Finch.FinchNotation.call_instance)((Finch.FinchNotation.variable_instance)(:*, (Finch.FinchNotation.finch_leaf_instance)(*)), (Finch.FinchNotation.access_instance)((Finch.FinchNotation.variable_instance)(:A, (Finch.FinchNotation.finch_leaf_instance)(A)), (Finch.FinchNotation.reader_instance)(), (Finch.FinchNotation.variable_instance)(:i, (Finch.FinchNotation.finch_leaf_instance)(i))), (Finch.FinchNotation.access_instance)((Finch.FinchNotation.variable_instance)(:B, (Finch.FinchNotation.finch_leaf_instance)(B)), (Finch.FinchNotation.reader_instance)(), (Finch.FinchNotation.variable_instance)(:i, (Finch.FinchNotation.finch_leaf_instance)(i))))))\n                    end\n                end))\n    begin\n        C = Finch.get(_res_1, :C, C)\n    end\n    begin\n        _res_1\n    end\nend\n","category":"page"},{"location":"development/","page":"Development Guide","title":"Development Guide","text":"In the above output, @finch creates an AST of program instances, then calls Finch.execute on it. A program instance is a struct that contains the program to be executed along with its arguments. Although we can use the above constructors (e.g. loop_instance) to make our own program instance, it is most convenient to use the unexported macro Finch.finch_program_instance:","category":"page"},{"location":"development/","page":"Development Guide","title":"Development Guide","text":"julia> using Finch: @finch_program_instance\n\njulia> prgm = Finch.@finch_program_instance (C .= 0; @loop i C[i] = A[i] * B[i])\nsequence_instance(declare_instance(variable_instance(:C, C)literal_instance(0)), loop_instance(index_instance(:i), assign_instance(access_instance(variable_instance(:C, C), updater_instance(create_instance()), index_instance(:i)), literal_instance(right), call_instance(variable_instance(:*, *), access_instance(variable_instance(:A, A), reader_instance(), index_instance(:i)), access_instance(variable_instance(:B, B), reader_instance(), index_instance(:i))))))","category":"page"},{"location":"development/","page":"Development Guide","title":"Development Guide","text":"As we can see, our program instance contains not only the AST to be executed, but also the data to execute the program with. The type of the program instance contains only the program portion; there may be many program instances with different inputs, but the same program type. We can run our program using Finch.execute, which returns a NamedTuple of outputs.","category":"page"},{"location":"development/","page":"Development Guide","title":"Development Guide","text":"julia> typeof(prgm)\nFinch.FinchNotation.SequenceInstance{Tuple{Finch.FinchNotation.DeclareInstance{Finch.FinchNotation.VariableInstance{:C, Fiber{Finch.SparseListLevel{Int64, Int64, Finch.ElementLevel{0, Int64}}}}, Finch.FinchNotation.LiteralInstance{0}}, Finch.FinchNotation.LoopInstance{Finch.FinchNotation.IndexInstance{:i}, Finch.FinchNotation.AssignInstance{Finch.FinchNotation.AccessInstance{Finch.FinchNotation.VariableInstance{:C, Fiber{Finch.SparseListLevel{Int64, Int64, Finch.ElementLevel{0, Int64}}}}, Finch.FinchNotation.UpdaterInstance{Finch.FinchNotation.CreateInstance}, Tuple{Finch.FinchNotation.IndexInstance{:i}}}, Finch.FinchNotation.LiteralInstance{Finch.FinchNotation.right}, Finch.FinchNotation.CallInstance{Finch.FinchNotation.VariableInstance{:*, Finch.FinchNotation.LiteralInstance{*}}, Tuple{Finch.FinchNotation.AccessInstance{Finch.FinchNotation.VariableInstance{:A, Fiber{Finch.SparseListLevel{Int64, Int64, Finch.ElementLevel{0, Int64}}}}, Finch.FinchNotation.ReaderInstance, Tuple{Finch.FinchNotation.IndexInstance{:i}}}, Finch.FinchNotation.AccessInstance{Finch.FinchNotation.VariableInstance{:B, Fiber{Finch.DenseLevel{Int64, Finch.ElementLevel{0, Int64}}}}, Finch.FinchNotation.ReaderInstance, Tuple{Finch.FinchNotation.IndexInstance{:i}}}}}}}}}\n\njulia> C = Finch.execute(prgm).C\nSparseList (0) [1:5]\n├─[2]: 24\n├─[5]: 45","category":"page"},{"location":"development/","page":"Development Guide","title":"Development Guide","text":"This functionality is sufficient for building finch kernels programatically. For example, if we wish to define a function pointwise_sum() that takes the pointwise sum of a variable number of vector inputs, we might implement it as follows:","category":"page"},{"location":"development/","page":"Development Guide","title":"Development Guide","text":"julia> function pointwise_sum(As...)\n           B = @fiber(d(e(0)))\n           isempty(As) && return B\n           i = Finch.FinchNotation.index_instance(:i)\n           A_vars = [Finch.FinchNotation.variable_instance(Symbol(:A, n), As[n]) for n in 1:length(As)]\n           #create a list of variable instances with different names to hold the input tensors\n           ex = @finch_program_instance 0\n           for A_var in A_vars\n               ex = @finch_program_instance $A_var[i] + $ex\n           end\n           prgm = @finch_program_instance (B .= 0; @loop i B[i] = $ex)\n           return Finch.execute(prgm).B\n       end\npointwise_sum (generic function with 1 method)\n\njulia> pointwise_sum([1, 2], [3, 4])\nDense [1:2]\n├─[1]: 4\n├─[2]: 6\n","category":"page"},{"location":"development/#Virtualization","page":"Development Guide","title":"Virtualization","text":"","category":"section"},{"location":"development/","page":"Development Guide","title":"Development Guide","text":"TODO more on the way...","category":"page"},{"location":"development/#Tensor-Life-Cycle","page":"Development Guide","title":"Tensor Life Cycle","text":"","category":"section"},{"location":"development/","page":"Development Guide","title":"Development Guide","text":"Every virtual tensor must be in one of two modes: read-only mode or update-only mode. The following functions may be called on virtual tensors throughout their life cycle.","category":"page"},{"location":"development/","page":"Development Guide","title":"Development Guide","text":"initialize!\nget_reader\nget_updater\nfreeze!\ntrim!","category":"page"},{"location":"development/#Finch.get_reader","page":"Development Guide","title":"Finch.get_reader","text":"get_reader(tns, ctx, protos...)\n\nReturn an object (usually a looplet nest) capable of reading the read-only virtual tensor tns.  As soon as a read-only tensor enters scope, each subsequent read access will be initialized with a separate call to get_reader. protos is the list of protocols in each case.\n\n\n\n\n\n","category":"function"},{"location":"development/#Finch.get_updater","page":"Development Guide","title":"Finch.get_updater","text":"get_updater(tns, ctx, protos...)\n\nReturn an object (usually a looplet nest) capable of updating the update-only virtual tensor tns.  As soon as an update only tensor enters scope, each subsequent update access will be initialized with a separate call to get_updater.  protos is the list of protocols in each case.\n\n\n\n\n\n","category":"function"},{"location":"development/#Finch.freeze!","page":"Development Guide","title":"Finch.freeze!","text":"freeze!(tns, ctx)\n\nFreeze the update-only virtual tensor tns in the context ctx and return it. Afterwards, the tensor is read-only.\n\n\n\n\n\n","category":"function"},{"location":"development/#Finch.trim!","page":"Development Guide","title":"Finch.trim!","text":"trim!(tns, ctx)\n\nBefore returning a tensor from the finch program, trim any excess overallocated memory.\n\n\n\n\n\n","category":"function"},{"location":"development/#Fiber-internals","page":"Development Guide","title":"Fiber internals","text":"","category":"section"},{"location":"development/","page":"Development Guide","title":"Development Guide","text":"Fiber levels are implemented using the following methods:","category":"page"},{"location":"development/","page":"Development Guide","title":"Development Guide","text":"default\ninitialize_level!\nassemble_level!\nreassemble_level!\nfreeze_level!\nlevel_ndims\nlevel_size\nlevel_axes\nlevel_eltype\nlevel_default","category":"page"},{"location":"development/#Finch.default","page":"Development Guide","title":"Finch.default","text":"default(fbr)\n\nThe default for a fiber is the value that each element of the fiber will have after initialization. This value is most often zero, and defaults to nothing.\n\nSee also: declare!\n\n\n\n\n\n","category":"function"},{"location":"development/#Finch.assemble_level!","page":"Development Guide","title":"Finch.assemble_level!","text":"assemble_level!(lvl, ctx, pos, new_pos)\n\nAssemble and positions pos+1:new_pos in lvl, assuming positions 1:pos were previously assembled.\n\n\n\n\n\n","category":"function"},{"location":"development/#Finch.reassemble_level!","page":"Development Guide","title":"Finch.reassemble_level!","text":"reassemble_level!(lvl, ctx, pos_start, pos_end)\n\nSet the previously assempled positions from pos_start to pos_end to level_default(lvl).\n\n\n\n\n\n","category":"function"},{"location":"development/#Finch.freeze_level!","page":"Development Guide","title":"Finch.freeze_level!","text":"freeze_level!(lvl, ctx, pos)\n\nFreeze all fibers in lvl. Positions 1:pos need freezing.\n\n\n\n\n\n","category":"function"},{"location":"development/#Finch.level_ndims","page":"Development Guide","title":"Finch.level_ndims","text":"level_ndims(::Type{Lvl})\n\nThe result of level_ndims(Lvl) defines ndims for all subfibers in a level of type Lvl.\n\n\n\n\n\n","category":"function"},{"location":"development/#Finch.level_size","page":"Development Guide","title":"Finch.level_size","text":"level_size(lvl)\n\nThe result of level_size(lvl) defines the size of all subfibers in the level lvl.\n\n\n\n\n\n","category":"function"},{"location":"development/#Finch.level_axes","page":"Development Guide","title":"Finch.level_axes","text":"level_axes(lvl)\n\nThe result of level_axes(lvl) defines the axes of all subfibers in the level lvl.\n\n\n\n\n\n","category":"function"},{"location":"development/#Finch.level_eltype","page":"Development Guide","title":"Finch.level_eltype","text":"level_eltype(::Type{Lvl})\n\nThe result of level_eltype(Lvl) defines eltype for all subfibers in a level of type Lvl.\n\n\n\n\n\n","category":"function"},{"location":"development/#Finch.level_default","page":"Development Guide","title":"Finch.level_default","text":"level_default(::Type{Lvl})\n\nThe result of level_default(Lvl) defines default for all subfibers in a level of type Lvl.\n\n\n\n\n\n","category":"function"},{"location":"listing/","page":"The Deets","title":"The Deets","text":"CurrentModule = Finch","category":"page"},{"location":"listing/#Public-Functions","page":"The Deets","title":"Public Functions","text":"","category":"section"},{"location":"listing/","page":"The Deets","title":"The Deets","text":"Modules = [Finch]","category":"page"},{"location":"listing/#Finch.DenseData","page":"The Deets","title":"Finch.DenseData","text":"DenseData(lvl)\n\nRepresents a tensor A where each A[:, ..., :, i] is represented by lvl.\n\n\n\n\n\n","category":"type"},{"location":"listing/#Finch.ElementData","page":"The Deets","title":"Finch.ElementData","text":"ElementData(default, eltype)\n\nRepresents a scalar element of type eltype and default default.\n\n\n\n\n\n","category":"type"},{"location":"listing/#Finch.ExtrudeData","page":"The Deets","title":"Finch.ExtrudeData","text":"ExtrudeData(lvl)\n\nRepresents a tensor A where A[:, ..., :, 1] is the only slice, and is represented by lvl.\n\n\n\n\n\n","category":"type"},{"location":"listing/#Finch.Fiber","page":"The Deets","title":"Finch.Fiber","text":"Fiber(lvl)\n\nFiber represents the root of a level-tree tensor. To easily construct a valid fiber, use @fiber or fiber. Users should avoid calling this constructor directly.\n\nIn particular, Fiber represents the tensor at position 1 of lvl. The constructor Fiber(lvl) wraps a level assuming it is already in a valid state. The constructor Fiber!(lvl) first initializes lvl assuming no positions are valid.\n\n\n\n\n\n","category":"type"},{"location":"listing/#Finch.HollowData","page":"The Deets","title":"Finch.HollowData","text":"HollowData(lvl)\n\nRepresents a tensor which is represented by lvl but is sometimes entirely default(lvl).\n\n\n\n\n\n","category":"type"},{"location":"listing/#Finch.InstantiateTensors","page":"The Deets","title":"Finch.InstantiateTensors","text":"InstantiateTensors(ctx)\n\nA transformation to instantiate readers and updaters before executing an expression\n\nSee also: declare!\n\n\n\n\n\n","category":"type"},{"location":"listing/#Finch.LowerJulia-Tuple{Any, Finch.DimensionalizeStyle}","page":"The Deets","title":"Finch.LowerJulia","text":"TODO out of date     dimensionalize!(prgm, ctx)\n\nA program traversal which gathers dimensions of tensors based on shared indices. Index sharing is transitive, so A[i] = B[i] and B[j] = C[j] will induce a gathering of the dimensions of A, B, and C into one. The resulting dimensions are gathered into a Dimensions object, which can be accesed with an index name or a (tensor_name, mode_name) tuple.\n\nThe program is assumed to be in SSA form.\n\nSee also: virtual_size, virtual_resize, combinedim, TransformSSA\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.PatternLevel","page":"The Deets","title":"Finch.PatternLevel","text":"PatternLevel{D, [Tv]}()\n\nA subfiber of a pattern level is the Boolean value true, but it's default is false. PatternLevels are used to create tensors that represent which values are stored by other fibers. See pattern for usage examples.\n\nIn the @fiber constructor, p is an alias for ElementLevel.\n\njulia> @fiber(d(p(), 3))\nDense [1:3]\n├─[1]: true\n├─[2]: true\n├─[3]: true\n\n\n\n\n\n","category":"type"},{"location":"listing/#Finch.RepeatData","page":"The Deets","title":"Finch.RepeatData","text":"RepeatData(default, eltype)\n\nRepresents an array A[i] with many repeated runs of elements of type eltype and default default.\n\n\n\n\n\n","category":"type"},{"location":"listing/#Finch.RepeatRLELevel","page":"The Deets","title":"Finch.RepeatRLELevel","text":"RepeatRLELevel{[D], [Ti=Int], [Tp=Int], [Tv=typeof(D)]}([dim])\n\nA subfiber of a repeat level is a vector that only stores contiguous repeated values once. The RepeatRLELevel records locations of repeats using a sorted list. Optionally, dim is the size of the vectors.\n\nThe fibers have type Tv, initialized to D. D may optionally be given as the first argument.  Ti is the type of the last fiber index, and Tp is the type used for positions in the level.\n\nIn the @fiber constructor, rl is an alias for RepeatRLELevel.\n\njulia> @fiber(rl(0.0), [11, 11, 22, 22, 00, 00, 00, 33, 33])\nRepeatRLE (0.0) [1:9]\n├─[1:2]: 11.0\n├─[3:4]: 22.0\n├─[5:7]: 0.0\n├─[8:9]: 33.0\n├─[10:9]: 0.0\n\n\n\n\n\n\n","category":"type"},{"location":"listing/#Finch.SparseData","page":"The Deets","title":"Finch.SparseData","text":"SparseData(lvl)\n\nRepresents a tensor A where A[:, ..., :, i] is sometimes entirely default(lvl) and is sometimes represented by lvl.\n\n\n\n\n\n","category":"type"},{"location":"listing/#Finch.SubFiber","page":"The Deets","title":"Finch.SubFiber","text":"SubFiber(lvl, pos)\n\nSubFiber represents a fiber at position pos within lvl.\n\n\n\n\n\n","category":"type"},{"location":"listing/#Finch.base_rules-Tuple{Any, Any}","page":"The Deets","title":"Finch.base_rules","text":"base_rules(alg, ctx)\n\nThe basic rule set for Finch, uses the algebra to check properties of functions like associativity, commutativity, etc. Also assumes the context has a static hash names shash. This rule set simplifies, normalizes, and propagates constants, and is the basis for how Finch understands sparsity.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.choose-Tuple{Any}","page":"The Deets","title":"Finch.choose","text":"choose(z)(a, b)\n\nchoose(z) is a function which returns whichever of a or b is not isequal to z. If neither are z, then return a. Useful for getting the first nonfill value in a sparse array.\n\njulia> a = @fiber(sl(e(0.0)), [0, 1.1, 0, 4.4, 0])\nSparseList (0.0) [1:5]\n├─[2]: 1.1\n├─[4]: 4.4\n\njulia> x = Scalar(0.0); @finch @loop i x[] <<choose(0.0)>>= a[i];\n\njulia> x[]\n1.1\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.collapse_rep-Tuple{Any}","page":"The Deets","title":"Finch.collapse_rep","text":"data_rep(tns)\n\nNormalize a trait object to collapse subfiber information into the parent fiber.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.combinedim-Tuple{Any, Any, Any}","page":"The Deets","title":"Finch.combinedim","text":"combinedim(ctx, a, b)\n\nCombine the two dimensions a and b.  To avoid ambiguity, only define one of\n\ncombinedim(ctx, ::A, ::B)\ncombinedim(ctx, ::B, ::A)\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.countstored-Tuple{Fiber}","page":"The Deets","title":"Finch.countstored","text":"countstored(arr)\n\nReturn the number of stored elements in arr. If there are explicitly stored default elements, they are counted too.\n\nSee also: (nnz)(https://docs.julialang.org/en/v1/stdlib/SparseArrays/#SparseArrays.nnz)\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.data_rep-Tuple{Any}","page":"The Deets","title":"Finch.data_rep","text":"data_rep(tns)\n\nReturn a trait object representing everything that can be learned about the data based on the storage format (type) of the tensor\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.declare!-Tuple{Any, Any, Any}","page":"The Deets","title":"Finch.declare!","text":"declare!(tns, ctx, init)\n\nDeclare the read-only virtual tensor tns in the context ctx with a starting value of init and return it. Afterwards the tensor is update-only.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.declare_level!","page":"The Deets","title":"Finch.declare_level!","text":"declare_level!(lvl, ctx, pos, init)\n\nInitialize and thaw all fibers within lvl, assuming positions 1:pos were previously assembled and frozen. The resulting level has no assembled positions.\n\n\n\n\n\n","category":"function"},{"location":"listing/#Finch.f_code-Tuple{Val{:d}}","page":"The Deets","title":"Finch.f_code","text":"f_code(d) = DenseLevel.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.f_code-Tuple{Val{:e}}","page":"The Deets","title":"Finch.f_code","text":"f_code(e) = ElementLevel.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.f_code-Tuple{Val{:p}}","page":"The Deets","title":"Finch.f_code","text":"f_code(p) = PatternLevel.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.f_code-Tuple{Val{:rl}}","page":"The Deets","title":"Finch.f_code","text":"f_code(rl) = RepeatRLELevel.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.f_code-Tuple{Val{:sbm}}","page":"The Deets","title":"Finch.f_code","text":"f_code(sbm) = SparseByteMapLevel.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.f_code-Tuple{Val{:sc}}","page":"The Deets","title":"Finch.f_code","text":"f_code(sc) = SparseCOOLevel.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.f_code-Tuple{Val{:sh}}","page":"The Deets","title":"Finch.f_code","text":"f_code(sh) = SparseHashLevel.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.f_code-Tuple{Val{:sl}}","page":"The Deets","title":"Finch.f_code","text":"f_code(l) = SparseListLevel.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.f_code-Tuple{Val{:svb}}","page":"The Deets","title":"Finch.f_code","text":"f_code(svb) = SparseVBLLevel.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.ffindnz-Tuple{Any}","page":"The Deets","title":"Finch.ffindnz","text":"ffindnz(arr)\n\nReturn the nonzero elements of arr, as Finch understands arr. Returns (I, V), where I is a tuple of coordinate vectors, one for each mode of arr, and V is a vector of corresponding nonzero values, which can be passed to fsparse.\n\nSee also: (findnz)(https://docs.julialang.org/en/v1/stdlib/SparseArrays/#SparseArrays.findnz)\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.fiber","page":"The Deets","title":"Finch.fiber","text":"fiber(arr, default = zero(eltype(arr)))\n\nCopies an array-like object arr into a corresponding, similar Fiber datastructure. default is the default value to use for initialization and sparse compression.\n\nSee also: fiber!\n\nExamples\n\njulia> println(summary(fiber(sparse([1 0; 0 1]))))\n2×2 @fiber(d(sl(e(0))))\n\njulia> println(summary(fiber(ones(3, 2, 4))))\n3×2×4 @fiber(d(d(d(e(0.0)))))\n\n\n\n\n\n","category":"function"},{"location":"listing/#Finch.fiber!","page":"The Deets","title":"Finch.fiber!","text":"fiber!(arr, default = zero(eltype(arr)))\n\nLike fiber, copies an array-like object arr into a corresponding, similar Fiber datastructure. However, fiber! reuses memory whenever possible, meaning arr may be rendered unusable.\n\n\n\n\n\n","category":"function"},{"location":"listing/#Finch.fiber_ctr","page":"The Deets","title":"Finch.fiber_ctr","text":"fiber_ctr(tns, protos...)\n\nReturn an expression that would construct a fiber suitable to hold data with a representation described by tns. Assumes representation is collapsed.\n\n\n\n\n\n","category":"function"},{"location":"listing/#Finch.freeze_level!-Tuple{Any, Any, Any}","page":"The Deets","title":"Finch.freeze_level!","text":"freeze_level!(lvl, ctx, pos)\n\nFreeze all fibers in lvl. Positions 1:pos need freezing.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.fsparse","page":"The Deets","title":"Finch.fsparse","text":"fsparse(I::Tuple, V,[ M::Tuple, combine])\n\nCreate a sparse COO fiber S such that size(S) == M and S[(i[q] for i = I)...] = V[q]. The combine function is used to combine duplicates. If M is not specified, it is set to map(maximum, I). If the combine function is not supplied, combine defaults to + unless the elements of V are Booleans in which case combine defaults to |. All elements of I must satisfy 1 <= I[n][q] <= M[n].  Numerical zeros are retained as structural nonzeros; to drop numerical zeros, use dropzeros!.\n\nSee also: sparse\n\nExamples\n\njulia> I = (     [1, 2, 3],     [1, 2, 3],     [1, 2, 3]);\n\njulia> V = [1.0; 2.0; 3.0];\n\njulia> fsparse(I, V) SparseCOO (0.0) [1:3×1:3×1:3] │ │ │  └─└─└─[1, 1, 1] [2, 2, 2] [3, 3, 3]       1.0       2.0       3.0    \n\n\n\n\n\n","category":"function"},{"location":"listing/#Finch.fsparse!","page":"The Deets","title":"Finch.fsparse!","text":"fsparse!(I::Tuple, V,[ M::Tuple])\n\nLike fsparse, but the coordinates must be sorted and unique, and memory is reused.\n\n\n\n\n\n","category":"function"},{"location":"listing/#Finch.fsprand-Union{Tuple{T}, Tuple{Tuple, AbstractFloat, Function, Type{T}}} where T","page":"The Deets","title":"Finch.fsprand","text":"fsprand([rng],[type], m::Tuple,p::AbstractFloat,[rfn])\n\nCreate a random sparse tensor of size m in COO format, in which the probability of any element being nonzero is independently given by p (and hence the mean density of nonzeros is also exactly p). Nonzero values are sampled from the distribution specified by rfn and have the type type. The uniform distribution is used in case rfn is not specified. The optional rng argument specifies a random number generator.\n\nSee also: (sprand)(https://docs.julialang.org/en/v1/stdlib/SparseArrays/#SparseArrays.sprand)\n\nExamples\n\njulia> fsprand(Bool, (3, 3), 0.5)\nSparseCOO (false) [1:3,1:3]\n├─├─[1, 1]: true\n├─├─[1, 3]: false\n├─├─[2, 2]: true\n├─├─[2, 3]: true\n├─├─[3, 3]: true  \n\njulia> fsprand(Float64, (2, 2, 2), 0.5)\nSparseCOO (0.0) [1:2,1:2,1:2]\n├─├─├─[1, 2, 2]: 0.0\n├─├─├─[2, 1, 1]: 0.0\n├─├─├─[2, 1, 2]: 0.7491940599574348 \n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.fspzeros-Tuple{Any}","page":"The Deets","title":"Finch.fspzeros","text":"fspzeros([type], shape::Tuple)\n\nCreate a random zero tensor of size m, with elements of type type. The tensor is in COO format.\n\nSee also: (spzeros)(https://docs.julialang.org/en/v1/stdlib/SparseArrays/#SparseArrays.spzeros)\n\nExamples\n\njulia> fspzeros(Bool, (3, 3))\nSparseCOO (false) [1:3,1:3]\n    \njulia> fspzeros(Float64, (2, 2, 2))\nSparseCOO (0.0) [1:2,1:2,1:2]\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.get_reader-Tuple{Any, Any, Vararg{Any}}","page":"The Deets","title":"Finch.get_reader","text":"get_reader(tns, ctx, protos...)\n\nReturn an object (usually a looplet nest) capable of reading the read-only virtual tensor tns.  As soon as a read-only tensor enters scope, each subsequent read access will be initialized with a separate call to get_reader. protos is the list of protocols in each case.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.get_updater-Tuple{Any, Any, Vararg{Any}}","page":"The Deets","title":"Finch.get_updater","text":"get_updater(tns, ctx, protos...)\n\nReturn an object (usually a looplet nest) capable of updating the update-only virtual tensor tns.  As soon as an update only tensor enters scope, each subsequent update access will be initialized with a separate call to get_updater.  protos is the list of protocols in each case.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.getindex_rep-Tuple{Any, Vararg{Any}}","page":"The Deets","title":"Finch.getindex_rep","text":"getindex_rep(tns, idxs...)\n\nReturn a trait object representing the result of calling getindex(tns, idxs...) on the tensor represented by tns. Assumes traits are in collapsed form.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.getname","page":"The Deets","title":"Finch.getname","text":"getname(ex)\n\nReturn the name of the index expression ex. The name serves as a unique identifier and often corresponds to the variable name which holds a tensor. Tensors can have the same name only if they are === to each other. The names of indices are used to distinguish the loops they reference.\n\n#TODO this function shouldn't exist\n\n\n\n\n\n","category":"function"},{"location":"listing/#Finch.getresults-Tuple{Finch.FinchNotation.FinchNode}","page":"The Deets","title":"Finch.getresults","text":"getresults(prgm)\n\nReturn an iterator over the properly modified tensors in a finch program\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.getrules-NTuple{4, Any}","page":"The Deets","title":"Finch.getrules","text":"getrules(alg, ctx::LowerJulia, var, tns)\n\nReturn a list of constant propagation rules for a tensor stored in variable var.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.getrules-Tuple{Any, Any}","page":"The Deets","title":"Finch.getrules","text":"getrules(alg, ctx)\n\nReturn an array of rules to use for annihilation/simplification during  compilation. One can dispatch on the alg trait to specialize the rule set for different algebras.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.getunbound-Tuple{Any}","page":"The Deets","title":"Finch.getunbound","text":"getunbound(stmt)\n\nReturn an iterator over the names in an index expression that have yet to be bound.\n\njulia> getunbound(@finch_program @loop i :a[i, j] += 2)\n[j]\njulia> getunbound(@finch_program i + j * 2 * i)\n[i, j]\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.getvalue-Tuple{Any}","page":"The Deets","title":"Finch.getvalue","text":"getvalue(ex)\n\nIf isliteral(ex) is true, return the value of ex. Defaults to the identity.\n\nSee also: isliteral\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.isannihilator-Tuple{Any, Any, Any}","page":"The Deets","title":"Finch.isannihilator","text":"isannihilator(algebra, f, x)\n\nReturn true when f(a..., x, b...) = x in algebra.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.isassociative-Tuple{Any, Any}","page":"The Deets","title":"Finch.isassociative","text":"isassociative(algebra, f)\n\nReturn true when f(a..., f(b...), c...) = f(a..., b..., c...) in algebra.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.iscommutative-Tuple{Any, Any}","page":"The Deets","title":"Finch.iscommutative","text":"iscommutative(algebra, f)\n\nReturn true when for all permutations p, f(a...) = f(a[p]...) in algebra.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.isdistributive-Tuple{Any, Any, Any}","page":"The Deets","title":"Finch.isdistributive","text":"isidempotent(algebra, f)\n\nReturn true when f(a, b) = f(f(a, b), b) in algebra.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.isidempotent-Tuple{Any, Any}","page":"The Deets","title":"Finch.isidempotent","text":"isidempotent(algebra, f)\n\nReturn true when f(a, b) = f(f(a, b), b) in algebra.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.isidentity-Tuple{Any}","page":"The Deets","title":"Finch.isidentity","text":"isidentity(algebra, f, x)\n\nReturn true when f(a..., x, b...) = f(a..., b...) in algebra.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.isinverse-Tuple{Any, Any, Any}","page":"The Deets","title":"Finch.isinverse","text":"isinverse(algebra, f, g)\n\nReturn true when f(a, g(a)) is the identity under f in algebra.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.isinvolution-Tuple{Any, Any}","page":"The Deets","title":"Finch.isinvolution","text":"isinvolution(algebra, f)\n\nReturn true when f(f(a)) = a in algebra.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.lift_broadcast-Union{Tuple{Base.Broadcast.Broadcasted{Style, Axes, F}}, Tuple{F}, Tuple{Axes}, Tuple{Style}} where {Style, Axes, F<:Function}","page":"The Deets","title":"Finch.lift_broadcast","text":"lift_broadcast(bc)\n\nAttempt to lift broadcast fields to the type domain for Finch analysis\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.maxby-Tuple{Any, Any}","page":"The Deets","title":"Finch.maxby","text":"maxby(a, b)\n\nReturn the max of a or b, comparing them by a[1] and b[1], and breaking ties to the left. Useful for implementing argmax operations:\n\njulia> a = [7.7, 3.3, 9.9, 3.3, 9.9]; x = Scalar(-Inf => 0);\n\njulia> @finch @loop i x[] <<maxby>>= a[i] => i;\n\njulia> x[]\n9.9 => 3\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.minby-Tuple{Any, Any}","page":"The Deets","title":"Finch.minby","text":"minby(a, b)\n\nReturn the min of a or b, comparing them by a[1] and b[1], and breaking ties to the left. Useful for implementing argmin operations:\n\njulia> a = [7.7, 3.3, 9.9, 3.3, 9.9]; x = Scalar(Inf => 0);\n\njulia> @finch @loop i x[] <<minby>>= a[i] => i;\n\njulia> x[]\n3.3 => 2\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.pattern!-Tuple{Fiber}","page":"The Deets","title":"Finch.pattern!","text":"pattern!(fbr)\n\nReturn the pattern of fbr. That is, return a fiber which is true wherever fbr is structurally unequal to it's default. May reuse memory and render the original fiber unusable when modified.\n\njulia> A = @fiber(sl(e(0.0), 10), [2.0, 0.0, 3.0, 0.0, 4.0, 0.0, 5.0, 0.0, 6.0, 0.0])\nSparseList (0.0) [1:10]\n├─[1]: 2.0\n├─[3]: 3.0\n├─[5]: 4.0\n├─[7]: 5.0\n├─[9]: 6.0\n\njulia> pattern!(A)\nSparseList (false) [1:10]\n├─[1]: true\n├─[3]: true\n├─[5]: true\n├─[7]: true\n├─[9]: true\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.redefault!-Tuple{Fiber, Any}","page":"The Deets","title":"Finch.redefault!","text":"redefault!(fbr, init)\n\nReturn a fiber which is equal to fbr, but with the default (implicit) value set to init.  May reuse memory and render the original fiber unusable when modified.\n\njulia> A = @fiber(sl(e(0.0), 10), [2.0, 0.0, 3.0, 0.0, 4.0, 0.0, 5.0, 0.0, 6.0, 0.0])\nSparseList (0.0) [1:10]\n├─[1]: 2.0\n├─[3]: 3.0\n├─[5]: 4.0\n├─[7]: 5.0\n├─[9]: 6.0\n\njulia> redefault!(A, Inf)\nSparseList (Inf) [1:10]\n├─[1]: 2.0\n├─[3]: 3.0\n├─[5]: 4.0\n├─[7]: 5.0\n├─[9]: 6.0\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.reduce_rep","page":"The Deets","title":"Finch.reduce_rep","text":"reduce_rep(op, tns, dims)\n\nReturn a trait object representing the result of reducing a tensor represented by tns on dims by op.\n\n\n\n\n\n","category":"function"},{"location":"listing/#Finch.scansearch-Union{Tuple{T}, Tuple{Any, Any, T, T}} where T<:Integer","page":"The Deets","title":"Finch.scansearch","text":"scansearch(v, x, lo, hi)\n\nreturn the first value of v greater than or equal to x, within the range lo:hi. Return hi+1 if all values are less than x.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.setname","page":"The Deets","title":"Finch.setname","text":"setname(ex, name)\n\nReturn a new expression, identical to ex, with the name name.\n\n\n\n\n\n","category":"function"},{"location":"listing/#Finch.striplines-Tuple{Expr}","page":"The Deets","title":"Finch.striplines","text":"striplines(ex)\n\nRemove line numbers\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.thaw!-Tuple{Any, Any}","page":"The Deets","title":"Finch.thaw!","text":"thaw!(tns, ctx)\n\nThaw the read-only virtual tensor tns in the context ctx and return it. Afterwards, the tensor is update-only.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.trim!-Tuple{Any, Any}","page":"The Deets","title":"Finch.trim!","text":"trim!(tns, ctx)\n\nBefore returning a tensor from the finch program, trim any excess overallocated memory.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.unblock-Tuple{Expr}","page":"The Deets","title":"Finch.unblock","text":"unblock(ex)\n\nFlatten any redundant blocks into a single block, over the whole expression.\n\n\n\n\n\n","category":"method"},{"location":"listing/#Finch.virtual_size","page":"The Deets","title":"Finch.virtual_size","text":"virtual_size(tns, ctx)\n\nReturn a tuple of the dimensions of tns in the context ctx with access mode mode. This is a function similar in spirit to Base.axes.\n\n\n\n\n\n","category":"function"},{"location":"listing/#Finch.@fiber-Tuple{Any}","page":"The Deets","title":"Finch.@fiber","text":"@fiber ctr [arg]\n\nConstruct a fiber using abbreviated level constructor names. To override abbreviations, expressions may be interpolated with $. For example, Fiber(DenseLevel(SparseListLevel(Element(0.0)))) can also be constructed as @fiber(sl(d(e(0.0)))). Consult the documentation for the helper function f_code for a full listing of level format codes.\n\nOptionally, an argument may be specified to copy into the fiber. This expression allocates. Use fiber(arg) for a zero-cost copy, if available.\n\n\n\n\n\n","category":"macro"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Finch","category":"page"},{"location":"#Finch","page":"Home","title":"Finch","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Finch is an adaptable compiler for loop nests over structured arrays. Finch can specialize to tensors with runs of repeated values, or to tensors which are sparse (mostly zero). Finch supports general sparsity as well as many specialized sparsity patterns, like clustered nonzeros, diagonals, or triangles.  In addition to zero, Finch supports optimizations over arbitrary fill values and operators.","category":"page"},{"location":"","page":"Home","title":"Home","text":"At it's heart, Finch is powered by a domain specific language for coiteration, breaking structured iterators into units we call Looplets. The Looplets are lowered progressively, leaving several opportunities to rewrite and simplify intermediate expressions.","category":"page"},{"location":"#Installation:","page":"Home","title":"Installation:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"Finch\")","category":"page"},{"location":"#Usage:","page":"Home","title":"Usage:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We're working on adding more documentation, for now take a look at the benchmarks for a few example algorithms.","category":"page"},{"location":"algebra/","page":"Custom Functions","title":"Custom Functions","text":"CurrentModule = Finch","category":"page"},{"location":"algebra/#Custom-Functions","page":"Custom Functions","title":"Custom Functions","text":"","category":"section"},{"location":"algebra/","page":"Custom Functions","title":"Custom Functions","text":"Finch supports arbitrary Julia Base functions over isbits types. For your convenience, Finch defines a few useful functions that help express common array operations inside Finch:","category":"page"},{"location":"algebra/","page":"Custom Functions","title":"Custom Functions","text":"choose\nminby\nmaxby","category":"page"},{"location":"algebra/#Finch.choose","page":"Custom Functions","title":"Finch.choose","text":"choose(z)(a, b)\n\nchoose(z) is a function which returns whichever of a or b is not isequal to z. If neither are z, then return a. Useful for getting the first nonfill value in a sparse array.\n\njulia> a = @fiber(sl(e(0.0)), [0, 1.1, 0, 4.4, 0])\nSparseList (0.0) [1:5]\n├─[2]: 1.1\n├─[4]: 4.4\n\njulia> x = Scalar(0.0); @finch @loop i x[] <<choose(0.0)>>= a[i];\n\njulia> x[]\n1.1\n\n\n\n\n\n","category":"function"},{"location":"algebra/#Finch.minby","page":"Custom Functions","title":"Finch.minby","text":"minby(a, b)\n\nReturn the min of a or b, comparing them by a[1] and b[1], and breaking ties to the left. Useful for implementing argmin operations:\n\njulia> a = [7.7, 3.3, 9.9, 3.3, 9.9]; x = Scalar(Inf => 0);\n\njulia> @finch @loop i x[] <<minby>>= a[i] => i;\n\njulia> x[]\n3.3 => 2\n\n\n\n\n\n","category":"function"},{"location":"algebra/#Finch.maxby","page":"Custom Functions","title":"Finch.maxby","text":"maxby(a, b)\n\nReturn the max of a or b, comparing them by a[1] and b[1], and breaking ties to the left. Useful for implementing argmax operations:\n\njulia> a = [7.7, 3.3, 9.9, 3.3, 9.9]; x = Scalar(-Inf => 0);\n\njulia> @finch @loop i x[] <<maxby>>= a[i] => i;\n\njulia> x[]\n9.9 => 3\n\n\n\n\n\n","category":"function"},{"location":"algebra/","page":"Custom Functions","title":"Custom Functions","text":"Finch only supports incrementing assignments to arrays such as += or *=. If you would like to increment A[i...] by the value of ex with a custom reduction operator op, you may use the following syntax: A[i...] <<op>>= ex.","category":"page"},{"location":"algebra/#User-Functions","page":"Custom Functions","title":"User Functions","text":"","category":"section"},{"location":"algebra/","page":"Custom Functions","title":"Custom Functions","text":"Users can also define their own functions, and declare their properties to the Finch compiler as follows:","category":"page"},{"location":"algebra/#Register-User-Functions","page":"Custom Functions","title":"Register User Functions","text":"","category":"section"},{"location":"algebra/","page":"Custom Functions","title":"Custom Functions","text":"Finch uses generated functions to compile kernels. If any functions have been defined after Finch was loaded, Finch needs to be notified about them. The most correct approach is to create a trait datatype that subtypes Finch.AbstractAlgebra and call Finch.register on that type. After you call register, that subtype reflects the methods you know to be currently defined at that world age. You can pass your algebra to Finch to run Finch in that world age.","category":"page"},{"location":"algebra/#Declare-Algebraic-Properties","page":"Custom Functions","title":"Declare Algebraic Properties","text":"","category":"section"},{"location":"algebra/","page":"Custom Functions","title":"Custom Functions","text":"Users can help Finch optimize expressions over new functions by declaring key function properties in the algebra. Finch kernels can then be executed using the algebra.","category":"page"},{"location":"algebra/","page":"Custom Functions","title":"Custom Functions","text":"As an example, suppose we wanted to declare some properties for the greatest common divisor function gcd. This function is associative and commutative, and the greatest common divisor of 1 and anything else is 1, so 1 is an annihilator.","category":"page"},{"location":"algebra/","page":"Custom Functions","title":"Custom Functions","text":"We can express this by subtyping AbstractAlgebra and defining properties as follows:","category":"page"},{"location":"algebra/","page":"Custom Functions","title":"Custom Functions","text":"struct MyAlgebra <: AbstractAlgebra end\n\nFinch.isassociative(::MyAlgebra, ::typeof(gcd)) = true\nFinch.iscommutative(::MyAlgebra, ::typeof(gcd)) = true\nFinch.isannihilator(::MyAlgebra, ::typeof(gcd), x) = x == 1","category":"page"},{"location":"algebra/","page":"Custom Functions","title":"Custom Functions","text":"When you're all done defining functions that dispatch on your algebra, call Finch.register to register your new algebra in Finch.","category":"page"},{"location":"algebra/","page":"Custom Functions","title":"Custom Functions","text":"Finch.register(MyAlgebra)","category":"page"},{"location":"algebra/","page":"Custom Functions","title":"Custom Functions","text":"Then, we can call a kernel that uses our algebra!","category":"page"},{"location":"algebra/","page":"Custom Functions","title":"Custom Functions","text":"u = @fiber sl(e(1)) #TODO add some data\nv = @fiber sl(e(1)) #TODO add some data\nw = @fiber sl(e(1))\n\n@finch MyAlgebra() (w .= 1; @loop i w[i] = gcd(u[i], v[i]))","category":"page"},{"location":"algebra/#Properties","page":"Custom Functions","title":"Properties","text":"","category":"section"},{"location":"algebra/","page":"Custom Functions","title":"Custom Functions","text":"The full list of properties recognized by Finch is as follows:","category":"page"},{"location":"algebra/","page":"Custom Functions","title":"Custom Functions","text":"isassociative\niscommutative\nisdistributive\nisidempotent\nisidentity\nisannihilator\nisinverse\nisinvolution","category":"page"},{"location":"algebra/#Finch.isassociative","page":"Custom Functions","title":"Finch.isassociative","text":"isassociative(algebra, f)\n\nReturn true when f(a..., f(b...), c...) = f(a..., b..., c...) in algebra.\n\n\n\n\n\n","category":"function"},{"location":"algebra/#Finch.iscommutative","page":"Custom Functions","title":"Finch.iscommutative","text":"iscommutative(algebra, f)\n\nReturn true when for all permutations p, f(a...) = f(a[p]...) in algebra.\n\n\n\n\n\n","category":"function"},{"location":"algebra/#Finch.isdistributive","page":"Custom Functions","title":"Finch.isdistributive","text":"isidempotent(algebra, f)\n\nReturn true when f(a, b) = f(f(a, b), b) in algebra.\n\n\n\n\n\n","category":"function"},{"location":"algebra/#Finch.isidempotent","page":"Custom Functions","title":"Finch.isidempotent","text":"isidempotent(algebra, f)\n\nReturn true when f(a, b) = f(f(a, b), b) in algebra.\n\n\n\n\n\n","category":"function"},{"location":"algebra/#Finch.isidentity","page":"Custom Functions","title":"Finch.isidentity","text":"isidentity(algebra, f, x)\n\nReturn true when f(a..., x, b...) = f(a..., b...) in algebra.\n\n\n\n\n\n","category":"function"},{"location":"algebra/#Finch.isannihilator","page":"Custom Functions","title":"Finch.isannihilator","text":"isannihilator(algebra, f, x)\n\nReturn true when f(a..., x, b...) = x in algebra.\n\n\n\n\n\n","category":"function"},{"location":"algebra/#Finch.isinverse","page":"Custom Functions","title":"Finch.isinverse","text":"isinverse(algebra, f, g)\n\nReturn true when f(a, g(a)) is the identity under f in algebra.\n\n\n\n\n\n","category":"function"},{"location":"algebra/#Finch.isinvolution","page":"Custom Functions","title":"Finch.isinvolution","text":"isinvolution(algebra, f)\n\nReturn true when f(f(a)) = a in algebra.\n\n\n\n\n\n","category":"function"},{"location":"algebra/#Rewriting","page":"Custom Functions","title":"Rewriting","text":"","category":"section"},{"location":"algebra/","page":"Custom Functions","title":"Custom Functions","text":"One can also define custom rewrite rules by overloading the getrules function on your algebra.  Unless you want to write the full rule set from scratch, be sure to append your new rules to the old rules, which can be obtained by calling base_rules. Rules can be specified directly on Finch IR using RewriteTools.jl","category":"page"},{"location":"algebra/","page":"Custom Functions","title":"Custom Functions","text":"base_rules\ngetrules","category":"page"},{"location":"algebra/#Finch.base_rules","page":"Custom Functions","title":"Finch.base_rules","text":"base_rules(alg, ctx)\n\nThe basic rule set for Finch, uses the algebra to check properties of functions like associativity, commutativity, etc. Also assumes the context has a static hash names shash. This rule set simplifies, normalizes, and propagates constants, and is the basis for how Finch understands sparsity.\n\n\n\n\n\n","category":"function"},{"location":"algebra/#Finch.getrules","page":"Custom Functions","title":"Finch.getrules","text":"getrules(alg, ctx)\n\nReturn an array of rules to use for annihilation/simplification during  compilation. One can dispatch on the alg trait to specialize the rule set for different algebras.\n\n\n\n\n\ngetrules(alg, ctx::LowerJulia, var, tns)\n\nReturn a list of constant propagation rules for a tensor stored in variable var.\n\n\n\n\n\n","category":"function"}]
}
