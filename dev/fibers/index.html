<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Array Formats · Finch.jl</title><meta name="title" content="Array Formats · Finch.jl"/><meta property="og:title" content="Array Formats · Finch.jl"/><meta property="twitter:title" content="Array Formats · Finch.jl"/><meta name="description" content="Documentation for Finch.jl."/><meta property="og:description" content="Documentation for Finch.jl."/><meta property="twitter:description" content="Documentation for Finch.jl."/><meta property="og:url" content="https://willow-ahrens.github.io/Finch.jl/fibers/"/><meta property="twitter:url" content="https://willow-ahrens.github.io/Finch.jl/fibers/"/><link rel="canonical" href="https://willow-ahrens.github.io/Finch.jl/fibers/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Finch.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Finch.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../usage/">Usage</a></li><li><a class="tocitem" href="../semantics/">Semantics</a></li><li class="is-active"><a class="tocitem" href>Array Formats</a><ul class="internal"><li><a class="tocitem" href="#Types-and-Storage-of-Level"><span>Types and Storage of Level</span></a></li><li class="toplevel"><a class="tocitem" href="#Public-Functions"><span>Public Functions</span></a></li></ul></li><li><a class="tocitem" href="../algebra/">Custom Functions</a></li><li><a class="tocitem" href="../fileio/">Tensor File I/O</a></li><li><a class="tocitem" href="../interop/">C, C++, ...</a></li><li><a class="tocitem" href="../performance/">Performance Tips</a></li><li><a class="tocitem" href="../internals/">Internals</a></li><li><a class="tocitem" href="../directory_structure/">Directory Structure</a></li><li><a class="tocitem" href="../CONTRIBUTING/">Contributing</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../benchmark/">Benchmarking</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Array Formats</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Array Formats</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/willow-ahrens/Finch.jl/blob/main/docs/src/fibers.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Level-Formats"><a class="docs-heading-anchor" href="#Level-Formats">Level Formats</a><a id="Level-Formats-1"></a><a class="docs-heading-anchor-permalink" href="#Level-Formats" title="Permalink"></a></h1><p>Finch implements a flexible array datastructure called a fiber. Fibers represent arrays as rooted trees, where the child of each node is selected by an array index. Finch is column major, so in an expression <code>A[i_1, ..., i_N]</code>, the rightmost dimension <code>i_N</code> corresponds to the root level of the tree, and the leftmost dimension <code>i_1</code> corresponds to the leaf level. When the array is dense, the leftmost dimension has stop 1. We can convert the matrix <code>A</code> to a fiber with the <code>Fiber!</code> constructor:</p><pre><code class="language-julia-repl hljs">julia&gt; A = [0.0 0.0 4.4; 1.1 0.0 0.0; 2.2 0.0 5.5; 3.3 0.0 0.0]
4×3 Matrix{Float64}:
 0.0  0.0  4.4
 1.1  0.0  0.0
 2.2  0.0  5.5
 3.3  0.0  0.0
julia&gt; A_fbr = Fiber!(Dense(Dense(Element(0.0))), A)
Dense [:,1:3]
├─[:,1]: Dense [1:4]
│ ├─[1]: 0.0
│ ├─[2]: 1.1
│ ├─[3]: 2.2
│ ├─[4]: 3.3
├─[:,2]: Dense [1:4]
│ ├─[1]: 0.0
│ ├─[2]: 0.0
│ ├─[3]: 0.0
│ ├─[4]: 0.0
├─[:,3]: Dense [1:4]
│ ├─[1]: 4.4
│ ├─[2]: 0.0
│ ├─[3]: 5.5
│ ├─[4]: 0.0</code></pre><p>We refer to a node in the tree as a subfiber. All of the nodes at the same level are stored in the same datastructure, and disambiguated by an integer <code>position</code>.  In the above example, there are three levels: The rootmost level contains only one fiber, the root. The middle level has 3 subfibers, one for each column. The leafmost level has 12 subfibers, one for each element of the array.  For example, the first level is <code>A_fbr.lvl</code>, and we can represent it&#39;s third position as <code>SubFiber(A_fbr.lvl.lvl, 3)</code>. The second level is <code>A_fbr.lvl.lvl</code>, and we can access it&#39;s 9th position as <code>SubFiber(A_fbr.lvl.lvl.lvl, 9)</code>. For instructional purposes, you can use parentheses to call a fiber on an index to select among children of a fiber.</p><pre><code class="language-julia-repl hljs">julia&gt; Finch.SubFiber(A_fbr.lvl.lvl, 3)
Dense [1:4]
├─[1]: 4.4
├─[2]: 0.0
├─[3]: 5.5
├─[4]: 0.0

julia&gt; A_fbr[:, 3]
Dense [1:4]
├─[1]: 4.4
├─[2]: 0.0
├─[3]: 5.5
├─[4]: 0.0

julia&gt; A_fbr(3)
Dense [1:4]
├─[1]: 4.4
├─[2]: 0.0
├─[3]: 5.5
├─[4]: 0.0

julia&gt; Finch.SubFiber(A_fbr.lvl.lvl.lvl, 9)
4.4

julia&gt; A_fbr[1, 3]
4.4

julia&gt; A_fbr(3)(1)
4.4
</code></pre><p>When we print the tree in text, positions are numbered from top to bottom. However, if we visualize our tree with the root at the top, positions range from left to right:</p><p><img src="../assets/levels-A-d-d-e.png" alt="Dense Format Index Tree"/></p><p>Because our array is sparse, (mostly zero, or another fill value), it would be more efficient to store only the nonzero values. In Finch, each level is represented with a different format. A sparse level only stores non-fill values. This time, we&#39;ll use a fiber constructor with <code>sl</code> (for &quot;<code>SparseList</code> of nonzeros&quot;) instead of <code>d</code> (for &quot;<code>Dense</code>&quot;):</p><pre><code class="language-julia-repl hljs">julia&gt; A_fbr = Fiber!(Dense(SparseList(Element(0.0))), A)
Dense [:,1:3]
├─[:,1]: SparseList (0.0) [1:4]
│ ├─[2]: 1.1
│ ├─[3]: 2.2
│ ├─[4]: 3.3
├─[:,2]: SparseList (0.0) [1:4]
├─[:,3]: SparseList (0.0) [1:4]
│ ├─[1]: 4.4
│ ├─[3]: 5.5</code></pre><p><img src="../assets/levels-A-d-sl-e.png" alt="CSC Format Index Tree"/></p><p>Our <code>Dense(SparseList(Element(0.0)))</code> format is also known as <a href="https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_.28CSC_or_CCS.29">&quot;CSC&quot;</a> and is equivalent to <a href="https://sparsearrays.juliasparse.org/dev/#man-csc"><code>SparseMatrixCSC</code></a>. The <a href="#Finch.fiber!"><code>fiber!</code></a> function will perform a zero-cost copy between Finch fibers and sparse matrices, when available.  CSC is an excellent general-purpose representation when we expect most of the columns to have a few nonzeros. However, when most of the columns are entirely fill (a situation known as hypersparsity), it is better to compress the root level as well:</p><pre><code class="language-julia-repl hljs">julia&gt; A_fbr = Fiber!(SparseList(SparseList(Element(0.0))), A)
SparseList (0.0) [:,1:3]
├─[:,1]: SparseList (0.0) [1:4]
│ ├─[2]: 1.1
│ ├─[3]: 2.2
│ ├─[4]: 3.3
├─[:,3]: SparseList (0.0) [1:4]
│ ├─[1]: 4.4
│ ├─[3]: 5.5</code></pre><p><img src="../assets/levels-A-sl-sl-e.png" alt="DCSC Format Index Tree"/></p><p>Here we see that the entirely zero column has also been compressed. The <code>SparseList(SparseList(Element(0.0)))</code> format is also known as <a href="https://ieeexplore.ieee.org/document/4536313">&quot;DCSC&quot;</a>.</p><p>The <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.html">&quot;COO&quot;</a> (or &quot;Coordinate&quot;) format is often used in practice for ease of interchange between libraries. In an <code>N</code>-dimensional array <code>A</code>, COO stores <code>N</code> lists of indices <code>I_1, ..., I_N</code> where <code>A[I_1[p], ..., I_N[p]]</code> is the <code>p</code>^th stored value in column-major numbering. In Finch, <code>COO</code> is represented as a multi-index level, which can handle more than one index at once. We use curly brackets to declare the number of indices handled by the level:</p><pre><code class="language-julia-repl hljs">julia&gt; A_fbr = Fiber!(SparseCOO{2}(Element(0.0)), A)
SparseCOO (0.0) [1:4,1:3]
├─├─[2, 1]: 1.1
├─├─[3, 1]: 2.2
├─├─[4, 1]: 3.3
├─├─[1, 3]: 4.4
├─├─[3, 3]: 5.5</code></pre><p><img src="../assets/levels-A-sc2-e.png" alt="COO Format Index Tree"/></p><p>The COO format is compact and straightforward, but doesn&#39;t support random access. For random access, one should use the <code>SparseHash</code> format. A full listing of supported formats is described after a rough description of shared common internals of level, relating to types and storage.</p><h2 id="Types-and-Storage-of-Level"><a class="docs-heading-anchor" href="#Types-and-Storage-of-Level">Types and Storage of Level</a><a id="Types-and-Storage-of-Level-1"></a><a class="docs-heading-anchor-permalink" href="#Types-and-Storage-of-Level" title="Permalink"></a></h2><p>All levels have a <code>postype</code>, typically denoted as <code>Tp</code> in the constructors, used for internal pointer types but accessible by the function:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.postype" href="#Finch.postype"><code>Finch.postype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">postype(lvl)</code></pre><p>Return a position type with the same flavor as those used to store the positions of the fibers contained in <code>lvl</code>. The name position descends from the pos or position or Separation arrays found in many definitions of CSR or CSC. In Finch, positions should be data used to access either a subfiber or some other similar auxiliary data. Thus, we often end up iterating over positions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/b83f3069a43a29ec8587132fd30b9ac07000ddcc/src/tensors/levels/abstractlevel.jl#L106-L112">source</a></section></article><p>Additionally, many levels have a <code>Vp</code> or <code>Vi</code> in their constructors; these stand for vector of element type <code>Tp</code> or <code>Ti</code>.  More generally, levels are paramterized by the types that they use for storage. By default, all levels use <code>Vector</code>, but a user  could could change any or all of the storage types of a fiber so that the fiber would be stored on a GPU or CPU or some combination thereof,  or eveni just via a vector with a different allocation mechanism.  The storage type should behave like <code>AbstractArray</code>  and needs to implement the usual abstract array functions and <code>Base.resize!</code>. See the tests for an example. </p><p>When levels are constructed in short form as in the examples above, the index, position, and storage types are inferred from the level below. All the levels at the bottom of a Fiber (<code>Element, Pattern, Repeater</code>) specify an index type, position type, and storage type even if they don&#39;t need them. These are used by levels that take these as parameters. </p><h3 id="Move-to:-Copying-Fibers-to-a-new-storage-type."><a class="docs-heading-anchor" href="#Move-to:-Copying-Fibers-to-a-new-storage-type.">Move to: Copying Fibers to a new storage type.</a><a id="Move-to:-Copying-Fibers-to-a-new-storage-type.-1"></a><a class="docs-heading-anchor-permalink" href="#Move-to:-Copying-Fibers-to-a-new-storage-type." title="Permalink"></a></h3><p>If one needs to copy a fiber to another fiber with a different storage type, one can use the <code>moveto</code> function, described below.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.moveto" href="#Finch.moveto"><code>Finch.moveto</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">moveto(arr, device)</code></pre><p>If the array is not on the given device, it creates a new version of this array on that device and copies the data in to it, according to the <code>device</code> trait.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/b83f3069a43a29ec8587132fd30b9ac07000ddcc/src/semantics.jl#L137-L142">source</a></section></article><h1 id="Public-Functions"><a class="docs-heading-anchor" href="#Public-Functions">Public Functions</a><a id="Public-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Public-Functions" title="Permalink"></a></h1><h3 id="Fiber-Constructors"><a class="docs-heading-anchor" href="#Fiber-Constructors">Fiber Constructors</a><a id="Fiber-Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Fiber-Constructors" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.Fiber!" href="#Finch.Fiber!"><code>Finch.Fiber!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Fiber!(ctr, [arg])</code></pre><p>Construct a fiber from a nest of levels. This function may allocate memory. Optionally, an argument may be specified to copy into the fiber. This expression allocates. Use <code>fiber(arg)</code> for a zero-cost copy, if available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/b83f3069a43a29ec8587132fd30b9ac07000ddcc/src/tensors/fibers.jl#L243-L249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.fiber" href="#Finch.fiber"><code>Finch.fiber</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fiber(arr, default = zero(eltype(arr)))</code></pre><p>Copies an array-like object <code>arr</code> into a corresponding, similar <code>Fiber</code> datastructure. <code>default</code> is the default value to use for initialization and sparse compression.</p><p>See also: <a href="#Finch.fiber!"><code>fiber!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; println(summary(fiber(sparse([1 0; 0 1]))))
2×2 Fiber!(Dense(SparseList(Element(0))))

julia&gt; println(summary(fiber(ones(3, 2, 4))))
3×2×4 Fiber!(Dense(Dense(Dense(Element(0.0)))))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/b83f3069a43a29ec8587132fd30b9ac07000ddcc/src/interface/fsparse.jl#L10-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.fiber!" href="#Finch.fiber!"><code>Finch.fiber!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fiber!(arr, default = zero(eltype(arr)))</code></pre><p>Like <a href="#Finch.fiber"><code>fiber</code></a>, copies an array-like object <code>arr</code> into a corresponding, similar <code>Fiber</code> datastructure. However, <code>fiber!</code> reuses memory whenever possible, meaning <code>arr</code> may be rendered unusable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/b83f3069a43a29ec8587132fd30b9ac07000ddcc/src/interface/fsparse.jl#L1-L7">source</a></section></article><h3 id="Level-Constructors"><a class="docs-heading-anchor" href="#Level-Constructors">Level Constructors</a><a id="Level-Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Level-Constructors" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.DenseLevel" href="#Finch.DenseLevel"><code>Finch.DenseLevel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DenseLevel{[Ti=Int]}(lvl, [dim])</code></pre><p>A subfiber of a dense level is an array which stores every slice <code>A[:, ..., :, i]</code> as a distinct subfiber in <code>lvl</code>. Optionally, <code>dim</code> is the size of the last dimension. <code>Ti</code> is the type of the indices used to index the level.</p><pre><code class="language-julia-repl hljs">julia&gt; ndims(Fiber!(Dense(Element(0.0))))
1

julia&gt; ndims(Fiber!(Dense(Dense(Element(0.0)))))
2

julia&gt; Fiber!(Dense(Dense(Element(0.0))), [1 2; 3 4])
Dense [:,1:2]
├─[:,1]: Dense [1:2]
│ ├─[1]: 1.0
│ ├─[2]: 3.0
├─[:,2]: Dense [1:2]
│ ├─[1]: 2.0
│ ├─[2]: 4.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/b83f3069a43a29ec8587132fd30b9ac07000ddcc/src/tensors/levels/denselevels.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.ElementLevel" href="#Finch.ElementLevel"><code>Finch.ElementLevel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ElementLevel{D, [Tv=typeof(D), Tp=Int, Val]}()</code></pre><p>A subfiber of an element level is a scalar of type <code>Tv</code>, initialized to <code>D</code>. <code>D</code> may optionally be given as the first argument.</p><p>The data is stored in a vector of type <code>Val</code> with <code>eltype(Val) = Tv</code>. The type <code>Ti</code> is the index type used to access Val.</p><pre><code class="language-julia-repl hljs">julia&gt; Fiber!(Dense(Element(0.0)), [1, 2, 3])
Dense [1:3]
├─[1]: 1.0
├─[2]: 2.0
├─[3]: 3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/b83f3069a43a29ec8587132fd30b9ac07000ddcc/src/tensors/levels/elementlevels.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.SparseListLevel" href="#Finch.SparseListLevel"><code>Finch.SparseListLevel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SparseListLevel{[Ti=Int], [Tp=Int], [Ptr=Vector{Tp}], [Idx=Vector{Ti}]}(lvl, [dim])</code></pre><p>A subfiber of a sparse level does not need to represent slices <code>A[:, ..., :, i]</code> which are entirely <a href="../internals/#Finch.default"><code>default</code></a>. Instead, only potentially non-default slices are stored as subfibers in <code>lvl</code>.  A sorted list is used to record which slices are stored. Optionally, <code>dim</code> is the size of the last dimension.</p><p><code>Ti</code> is the type of the last fiber index, and <code>Tp</code> is the type used for positions in the level. The types <code>Ptr</code> and <code>Idx</code> are the types of the arrays used to store positions and indicies. </p><pre><code class="language-julia-repl hljs">julia&gt; Fiber!(Dense(SparseList(Element(0.0))), [10 0 20; 30 0 0; 0 0 40])
Dense [:,1:3]
├─[:,1]: SparseList (0.0) [1:3]
│ ├─[1]: 10.0
│ ├─[2]: 30.0
├─[:,2]: SparseList (0.0) [1:3]
├─[:,3]: SparseList (0.0) [1:3]
│ ├─[1]: 20.0
│ ├─[3]: 40.0

julia&gt; Fiber!(SparseList(SparseList(Element(0.0))), [10 0 20; 30 0 0; 0 0 40])
SparseList (0.0) [:,1:3]
├─[:,1]: SparseList (0.0) [1:3]
│ ├─[1]: 10.0
│ ├─[2]: 30.0
├─[:,3]: SparseList (0.0) [1:3]
│ ├─[1]: 20.0
│ ├─[3]: 40.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/b83f3069a43a29ec8587132fd30b9ac07000ddcc/src/tensors/levels/sparselistlevels.jl#L1-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.SparseCOOLevel" href="#Finch.SparseCOOLevel"><code>Finch.SparseCOOLevel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SparseCOOLevel{[N], [TI=Tuple{Int...}], [Ptr], [Tbl]}(lvl, [dims])</code></pre><p>A subfiber of a sparse level does not need to represent slices which are entirely <a href="../internals/#Finch.default"><code>default</code></a>. Instead, only potentially non-default slices are stored as subfibers in <code>lvl</code>. The sparse coo level corresponds to <code>N</code> indices in the subfiber, so fibers in the sublevel are the slices <code>A[:, ..., :, i_1, ..., i_n]</code>.  A set of <code>N</code> lists (one for each index) are used to record which slices are stored. The coordinates (sets of <code>N</code> indices) are sorted in column major order.  Optionally, <code>dims</code> are the sizes of the last dimensions.</p><p><code>TI</code> is the type of the last <code>N</code> fiber indices, and <code>Tp</code> is the type used for positions in the level.</p><p>The type <code>Tbl</code> is an NTuple type where each entry k is a subtype <code>AbstractVector{TI[k]}</code>.</p><p>The type <code>Ptr</code> is the type for the pointer array.</p><pre><code class="language-julia-repl hljs">julia&gt; Fiber!(Dense(SparseCOO{1}(Element(0.0))), [10 0 20; 30 0 0; 0 0 40])
Dense [:,1:3]
├─[:,1]: SparseCOO (0.0) [1:3]
│ ├─[1]: 10.0
│ ├─[2]: 30.0
├─[:,2]: SparseCOO (0.0) [1:3]
├─[:,3]: SparseCOO (0.0) [1:3]
│ ├─[1]: 20.0
│ ├─[3]: 40.0

julia&gt; Fiber!(SparseCOO{2}(Element(0.0)), [10 0 20; 30 0 0; 0 0 40])
SparseCOO (0.0) [1:3,1:3]
├─├─[1, 1]: 10.0
├─├─[2, 1]: 30.0
├─├─[1, 3]: 20.0
├─├─[3, 3]: 40.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/b83f3069a43a29ec8587132fd30b9ac07000ddcc/src/tensors/levels/sparsecoolevels.jl#L1-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.SparseHashLevel" href="#Finch.SparseHashLevel"><code>Finch.SparseHashLevel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SparseHashLevel{[N], [TI=Tuple{Int...}], [Ptr], [Tbl], [Srt]}(lvl, [dims])</code></pre><p>A subfiber of a sparse level does not need to represent slices which are entirely <a href="../internals/#Finch.default"><code>default</code></a>. Instead, only potentially non-default slices are stored as subfibers in <code>lvl</code>. The sparse hash level corresponds to <code>N</code> indices in the subfiber, so fibers in the sublevel are the slices <code>A[:, ..., :, i_1, ..., i_n]</code>.  A hash table is used to record which slices are stored. Optionally, <code>dims</code> are the sizes of the last dimensions.</p><p><code>TI</code> is the type of the last <code>N</code> fiber indices, and <code>Tp</code> is the type used for positions in the level. <code>Tbl</code> is the type of the dictionary used to do hashing, <code>Ptr</code> stores the positions of subfibers, and <code>Srt</code> stores the sorted key/value pairs in the hash table.</p><pre><code class="language-julia-repl hljs">julia&gt; Fiber!(Dense(SparseHash{1}(Element(0.0))), [10 0 20; 30 0 0; 0 0 40])
Dense [:,1:3]
├─[:,1]: SparseHash (0.0) [1:3]
│ ├─[1]: 10.0
│ ├─[2]: 30.0
├─[:,2]: SparseHash (0.0) [1:3]
├─[:,3]: SparseHash (0.0) [1:3]
│ ├─[1]: 20.0
│ ├─[3]: 40.0

julia&gt; Fiber!(SparseHash{2}(Element(0.0)), [10 0 20; 30 0 0; 0 0 40])
SparseHash (0.0) [1:3,1:3]
├─├─[1, 1]: 10.0
├─├─[2, 1]: 30.0
├─├─[1, 3]: 20.0
├─├─[3, 3]: 40.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/b83f3069a43a29ec8587132fd30b9ac07000ddcc/src/tensors/levels/sparsehashlevels.jl#L1-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.SparseTriangleLevel" href="#Finch.SparseTriangleLevel"><code>Finch.SparseTriangleLevel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SparseTriangleLevel{[N], [Ti=Int]}(lvl, [dims])</code></pre><p>The sparse triangle level stores the upper triangle of <code>N</code> indices in the subfiber, so fibers in the sublevel are the slices <code>A[:, ..., :, i_1, ..., i_n]</code>, where <code>i_1 &lt;= ... &lt;= i_n</code>.  A packed representation is used to encode the subfiber. Optionally, <code>dims</code> are the sizes of the last dimensions.</p><p><code>Ti</code> is the type of the last <code>N</code> fiber indices.</p><pre><code class="language-julia-repl hljs">julia&gt; Fiber!(SparseTriangle{2}(Element(0.0)), [10 0 20; 30 0 0; 0 0 40])
SparseTriangle (0.0) [1:3]
├─├─[1, 1]: 10.0
├─├─[1, 2]: 0.0
│ ⋮
├─├─[2, 3]: 0.0
├─├─[3, 3]: 40.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/b83f3069a43a29ec8587132fd30b9ac07000ddcc/src/tensors/levels/sparsetrianglelevels.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.SparseByteMapLevel" href="#Finch.SparseByteMapLevel"><code>Finch.SparseByteMapLevel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SparseByteMapLevel{[Ti=Tuple{Int...}], [Tp=Int], [Ptr] [Tbl]}(lvl, [dims])</code></pre><p>Like the <a href="#Finch.SparseListLevel"><code>SparseListLevel</code></a>, but a dense bitmap is used to encode which slices are stored. This allows the ByteMap level to support random access.</p><p><code>Ti</code> is the type of the last fiber index, and <code>Tp</code> is the type used for positions in the level. </p><pre><code class="language-julia-repl hljs">julia&gt; Fiber!(Dense(SparseByteMap(Element(0.0))), [10 0 20; 30 0 0; 0 0 40])
Dense [:,1:3]
├─[:,1]: SparseByteMap (0.0) [1:3]
│ ├─[1]: 10.0
│ ├─[2]: 30.0
├─[:,2]: SparseByteMap (0.0) [1:3]
├─[:,3]: SparseByteMap (0.0) [1:3]
│ ├─[1]: 20.0
│ ├─[3]: 40.0

julia&gt; Fiber!(SparseByteMap(SparseByteMap(Element(0.0))), [10 0 20; 30 0 0; 0 0 40])
SparseByteMap (0.0) [:,1:3]
├─[:,1]: SparseByteMap (0.0) [1:3]
│ ├─[1]: 10.0
│ ├─[2]: 30.0
├─[:,3]: SparseByteMap (0.0) [1:3]
│ ├─[1]: 20.0
│ ├─[3]: 40.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/b83f3069a43a29ec8587132fd30b9ac07000ddcc/src/tensors/levels/sparsebytemaplevels.jl#L1-L30">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../semantics/">« Semantics</a><a class="docs-footer-nextpage" href="../algebra/">Custom Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Friday 5 January 2024 15:29">Friday 5 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
