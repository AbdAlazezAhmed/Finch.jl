<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · Finch.jl</title><meta name="title" content="Internals · Finch.jl"/><meta property="og:title" content="Internals · Finch.jl"/><meta property="twitter:title" content="Internals · Finch.jl"/><meta name="description" content="Documentation for Finch.jl."/><meta property="og:description" content="Documentation for Finch.jl."/><meta property="twitter:description" content="Documentation for Finch.jl."/><meta property="og:url" content="https://willow-ahrens.github.io/Finch.jl/internals/"/><meta property="twitter:url" content="https://willow-ahrens.github.io/Finch.jl/internals/"/><link rel="canonical" href="https://willow-ahrens.github.io/Finch.jl/internals/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Finch.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Finch.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../usage/">Usage</a></li><li><a class="tocitem" href="../semantics/">Semantics</a></li><li><a class="tocitem" href="../fibers/">Array Formats</a></li><li><a class="tocitem" href="../algebra/">Custom Functions</a></li><li><a class="tocitem" href="../fileio/">Tensor File I/O</a></li><li><a class="tocitem" href="../interop/">C, C++, ...</a></li><li><a class="tocitem" href="../performance/">Performance Tips</a></li><li class="is-active"><a class="tocitem" href>Internals</a><ul class="internal"><li><a class="tocitem" href="#Finch-Compilation"><span>Finch Compilation</span></a></li><li><a class="tocitem" href="#Finch-Notation"><span>Finch Notation</span></a></li><li><a class="tocitem" href="#Virtual-Tensor-Methods"><span>Virtual Tensor Methods</span></a></li><li><a class="tocitem" href="#Virtualization"><span>Virtualization</span></a></li><li><a class="tocitem" href="#Fiber-internals"><span>Fiber internals</span></a></li></ul></li><li><a class="tocitem" href="../directory_structure/">Directory Structure</a></li><li><a class="tocitem" href="../CONTRIBUTING/">Contributing</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../benchmark/">Benchmarking</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/willow-ahrens/Finch.jl/blob/main/docs/src/internals.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Finch-Compilation"><a class="docs-heading-anchor" href="#Finch-Compilation">Finch Compilation</a><a id="Finch-Compilation-1"></a><a class="docs-heading-anchor-permalink" href="#Finch-Compilation" title="Permalink"></a></h2><h2 id="Finch-Notation"><a class="docs-heading-anchor" href="#Finch-Notation">Finch Notation</a><a id="Finch-Notation-1"></a><a class="docs-heading-anchor-permalink" href="#Finch-Notation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.FinchNotation.FinchNode" href="#Finch.FinchNotation.FinchNode"><code>Finch.FinchNotation.FinchNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FinchNode</code></pre><p>A Finch IR node. Finch uses a variant of Concrete Index Notation as an intermediate representation. </p><p>The FinchNode struct represents many different Finch IR nodes. The nodes are differentiated by a <code>FinchNotation.FinchNodeKind</code> enum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/62790906329fb8dda102ad392c159be852315880/src/FinchNotation/nodes.jl#L164-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.FinchNotation.cached" href="#Finch.FinchNotation.cached"><code>Finch.FinchNotation.cached</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">cached(val, ref)</code></pre><p>Finch AST expression <code>val</code>, equivalent to the quoted expression <code>ref</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/62790906329fb8dda102ad392c159be852315880/src/FinchNotation/nodes.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.FinchNotation.finch_leaf" href="#Finch.FinchNotation.finch_leaf"><code>Finch.FinchNotation.finch_leaf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">finch_leaf(x)</code></pre><p>Return a terminal finch node wrapper around <code>x</code>. A convenience function to determine whether <code>x</code> should be understood by default as a literal, value, or virtual.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/62790906329fb8dda102ad392c159be852315880/src/FinchNotation/nodes.jl#L697-L703">source</a></section></article><h3 id="Program-Instances"><a class="docs-heading-anchor" href="#Program-Instances">Program Instances</a><a id="Program-Instances-1"></a><a class="docs-heading-anchor-permalink" href="#Program-Instances" title="Permalink"></a></h3><p>Finch relies heavily on Julia&#39;s <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/">metaprogramming capabilities</a> ( <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/#Macros">macros</a> and <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/#Generated-functions">generated functions</a> in particular) to produce code. To review briefly, a macro allows us to inspect the syntax of it&#39;s arguments and generate replacement syntax. A generated function allows us to inspect the type of the function arguments and produce code for a function body.</p><p>In normal Finch usage, we might call Finch as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; C = Fiber!(SparseList(Element(0)));

julia&gt; A = Fiber!(SparseList(Element(0)), [0, 2, 0, 0, 3]);


julia&gt; B = Fiber!(Dense(Element(0)), [11, 12, 13, 14, 15]);

julia&gt; @finch (C .= 0; for i=_; C[i] = A[i] * B[i] end);


julia&gt; C
SparseList (0) [1:5]
├─[2]: 24
├─[5]: 45</code></pre><p>The <a href="https://docs.julialang.org/en/v1/base/base/#Base.macroexpand"><code>@macroexpand</code></a> macro allows us to see the result of applying a macro. Let&#39;s examine what happens when we use the <code>@finch</code> macro (we&#39;ve stripped line numbers from the result to clean it up):</p><pre><code class="language-julia-repl hljs">julia&gt; (@macroexpand @finch (C .= 0; for i=_; C[i] = A[i] * B[i] end)) |&gt; Finch.striplines |&gt; Finch.regensym
quote
    _res_1 = (Finch.execute)((Finch.FinchNotation.block_instance)((Finch.FinchNotation.declare_instance)((Finch.FinchNotation.tag_instance)(variable_instance(:C), (Finch.FinchNotation.finch_leaf_instance)(C)), literal_instance(0)), begin
                    let i = index_instance(i)
                        (Finch.FinchNotation.loop_instance)(i, Finch.FinchNotation.Dimensionless(), (Finch.FinchNotation.assign_instance)((Finch.FinchNotation.access_instance)((Finch.FinchNotation.tag_instance)(variable_instance(:C), (Finch.FinchNotation.finch_leaf_instance)(C)), literal_instance(Finch.FinchNotation.Updater()), (Finch.FinchNotation.tag_instance)(variable_instance(:i), (Finch.FinchNotation.finch_leaf_instance)(i))), (Finch.FinchNotation.literal_instance)(Finch.FinchNotation.initwrite), (Finch.FinchNotation.call_instance)((Finch.FinchNotation.tag_instance)(variable_instance(:*), (Finch.FinchNotation.finch_leaf_instance)(*)), (Finch.FinchNotation.access_instance)((Finch.FinchNotation.tag_instance)(variable_instance(:A), (Finch.FinchNotation.finch_leaf_instance)(A)), literal_instance(Finch.FinchNotation.Reader()), (Finch.FinchNotation.tag_instance)(variable_instance(:i), (Finch.FinchNotation.finch_leaf_instance)(i))), (Finch.FinchNotation.access_instance)((Finch.FinchNotation.tag_instance)(variable_instance(:B), (Finch.FinchNotation.finch_leaf_instance)(B)), literal_instance(Finch.FinchNotation.Reader()), (Finch.FinchNotation.tag_instance)(variable_instance(:i), (Finch.FinchNotation.finch_leaf_instance)(i))))))
                    end
                end), (;))
    begin
        if Finch.haskey(_res_1, :C)
            C = _res_1[:C]
        end
    end
    begin
        _res_1
    end
end
</code></pre><p>In the above output, <code>@finch</code> creates an AST of program instances, then calls <code>Finch.execute</code> on it. A program instance is a struct that contains the program to be executed along with its arguments. Although we can use the above constructors (e.g. <code>loop_instance</code>) to make our own program instance, it is most convenient to use the unexported macro <code>Finch.finch_program_instance</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; using Finch: @finch_program_instance

julia&gt; prgm = Finch.@finch_program_instance (C .= 0; for i=_; C[i] = A[i] * B[i] end)
block_instance(declare_instance(tag_instance(:variable_instance(:C), Fiber(SparseList{Int64}(Element{0, Int64, Int64}([24, 45]), 5, [1, 3], [2, 5]))), literal_instance(0)), loop_instance(index_instance(i), Finch.FinchNotation.Dimensionless(), assign_instance(access_instance(tag_instance(:variable_instance(:C), Fiber(SparseList{Int64}(Element{0, Int64, Int64}([24, 45]), 5, [1, 3], [2, 5]))), literal_instance(Finch.FinchNotation.Updater()), tag_instance(:variable_instance(:i), index_instance(i))), literal_instance(initwrite), call_instance(tag_instance(:variable_instance(:*), literal_instance(*)), access_instance(tag_instance(:variable_instance(:A), Fiber(SparseList{Int64}(Element{0, Int64, Int64}([2, 3]), 5, [1, 3], [2, 5]))), literal_instance(Finch.FinchNotation.Reader()), tag_instance(:variable_instance(:i), index_instance(i))), access_instance(tag_instance(:variable_instance(:B), Fiber(Dense{Int64}(Element{0, Int64, Int64}([11, 12, 13, 14, 15]), 5))), literal_instance(Finch.FinchNotation.Reader()), tag_instance(:variable_instance(:i), index_instance(i)))))))</code></pre><p>As we can see, our program instance contains not only the AST to be executed, but also the data to execute the program with. The type of the program instance contains only the program portion; there may be many program instances with different inputs, but the same program type. We can run our program using <code>Finch.execute</code>, which returns a <code>NamedTuple</code> of outputs.</p><pre><code class="language-julia-repl hljs">julia&gt; typeof(prgm)
Finch.FinchNotation.BlockInstance{Tuple{Finch.FinchNotation.DeclareInstance{Finch.FinchNotation.TagInstance{Finch.FinchNotation.VariableInstance{:C}, Fiber{SparseListLevel{Int64, Vector{Int64}, Vector{Int64}, ElementLevel{0, Int64, Int64, Vector{Int64}}}}}, Finch.FinchNotation.LiteralInstance{0}}, Finch.FinchNotation.LoopInstance{Finch.FinchNotation.IndexInstance{:i}, Finch.FinchNotation.Dimensionless, Finch.FinchNotation.AssignInstance{Finch.FinchNotation.AccessInstance{Finch.FinchNotation.TagInstance{Finch.FinchNotation.VariableInstance{:C}, Fiber{SparseListLevel{Int64, Vector{Int64}, Vector{Int64}, ElementLevel{0, Int64, Int64, Vector{Int64}}}}}, Finch.FinchNotation.LiteralInstance{Finch.FinchNotation.Updater()}, Tuple{Finch.FinchNotation.TagInstance{Finch.FinchNotation.VariableInstance{:i}, Finch.FinchNotation.IndexInstance{:i}}}}, Finch.FinchNotation.LiteralInstance{Finch.FinchNotation.initwrite}, Finch.FinchNotation.CallInstance{Finch.FinchNotation.TagInstance{Finch.FinchNotation.VariableInstance{:*}, Finch.FinchNotation.LiteralInstance{*}}, Tuple{Finch.FinchNotation.AccessInstance{Finch.FinchNotation.TagInstance{Finch.FinchNotation.VariableInstance{:A}, Fiber{SparseListLevel{Int64, Vector{Int64}, Vector{Int64}, ElementLevel{0, Int64, Int64, Vector{Int64}}}}}, Finch.FinchNotation.LiteralInstance{Finch.FinchNotation.Reader()}, Tuple{Finch.FinchNotation.TagInstance{Finch.FinchNotation.VariableInstance{:i}, Finch.FinchNotation.IndexInstance{:i}}}}, Finch.FinchNotation.AccessInstance{Finch.FinchNotation.TagInstance{Finch.FinchNotation.VariableInstance{:B}, Fiber{DenseLevel{Int64, ElementLevel{0, Int64, Int64, Vector{Int64}}}}}, Finch.FinchNotation.LiteralInstance{Finch.FinchNotation.Reader()}, Tuple{Finch.FinchNotation.TagInstance{Finch.FinchNotation.VariableInstance{:i}, Finch.FinchNotation.IndexInstance{:i}}}}}}}}}}

julia&gt; C = Finch.execute(prgm).C
SparseList (0) [1:5]
├─[2]: 24
├─[5]: 45</code></pre><p>This functionality is sufficient for building finch kernels programatically. For example, if we wish to define a function <code>pointwise_sum()</code> that takes the pointwise sum of a variable number of vector inputs, we might implement it as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; function pointwise_sum(As...)
           B = Fiber!(Dense(Element(0)))
           isempty(As) &amp;&amp; return B
           i = Finch.FinchNotation.index_instance(:i)
           A_vars = [Finch.FinchNotation.tag_instance(Finch.FinchNotation.variable_instance(Symbol(:A, n)), As[n]) for n in 1:length(As)]
           #create a list of variable instances with different names to hold the input tensors
           ex = @finch_program_instance 0
           for A_var in A_vars
               ex = @finch_program_instance $A_var[i] + $ex
           end
           prgm = @finch_program_instance (B .= 0; for i=_; B[i] = $ex end)
           return Finch.execute(prgm).B
       end
pointwise_sum (generic function with 1 method)

julia&gt; pointwise_sum([1, 2], [3, 4])
Dense [1:2]
├─[1]: 4
├─[2]: 6
</code></pre><h2 id="Virtual-Tensor-Methods"><a class="docs-heading-anchor" href="#Virtual-Tensor-Methods">Virtual Tensor Methods</a><a id="Virtual-Tensor-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Virtual-Tensor-Methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.declare!" href="#Finch.declare!"><code>Finch.declare!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">declare!(tns, ctx, init)</code></pre><p>Declare the read-only virtual tensor <code>tns</code> in the context <code>ctx</code> with a starting value of <code>init</code> and return it. Afterwards the tensor is update-only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/62790906329fb8dda102ad392c159be852315880/src/semantics.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.instantiate" href="#Finch.instantiate"><code>Finch.instantiate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">instantiate(tns, ctx, mode, protos)</code></pre><p>Return an object (usually a looplet nest) capable of unfurling the  virtual tensor <code>tns</code>. Before executing a statement, each subsequent in-scope access will be initialized with a separate call to <code>instantiate</code>. <code>protos</code> is the list of protocols in each case.</p><p>The fallback for <code>instantiate</code> will iteratively move the last element of <code>protos</code> into the arguments of a function. This allows fibers to specialize on the last arguments of protos rather than the first, as Finch is column major.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/62790906329fb8dda102ad392c159be852315880/src/semantics.jl#L9-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.freeze!" href="#Finch.freeze!"><code>Finch.freeze!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">freeze!(tns, ctx)</code></pre><p>Freeze the update-only virtual tensor <code>tns</code> in the context <code>ctx</code> and return it. Afterwards, the tensor is read-only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/62790906329fb8dda102ad392c159be852315880/src/semantics.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.trim!" href="#Finch.trim!"><code>Finch.trim!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">trim!(tns, ctx)</code></pre><p>Before returning a tensor from the finch program, trim any excess overallocated memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/62790906329fb8dda102ad392c159be852315880/src/semantics.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.thaw!" href="#Finch.thaw!"><code>Finch.thaw!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">thaw!(tns, ctx)</code></pre><p>Thaw the read-only virtual tensor <code>tns</code> in the context <code>ctx</code> and return it. Afterwards, the tensor is update-only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/62790906329fb8dda102ad392c159be852315880/src/semantics.jl#L37-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.unfurl" href="#Finch.unfurl"><code>Finch.unfurl</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unfurl(tns, ctx, ext, protos...)</code></pre><p>Return an array object (usually a looplet nest) for lowering the virtual tensor <code>tns</code>. <code>ext</code> is the extent of the looplet. <code>protos</code> is the list of protocols that should be used for each index, but one doesn&#39;t need to unfurl all the indices at once.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/62790906329fb8dda102ad392c159be852315880/src/looplets/unfurl.jl#L18-L25">source</a></section></article><h2 id="Virtualization"><a class="docs-heading-anchor" href="#Virtualization">Virtualization</a><a id="Virtualization-1"></a><a class="docs-heading-anchor-permalink" href="#Virtualization" title="Permalink"></a></h2><p>Finch generates different code depending on the types of the arguments to the program. For example, in the following program, <code>A</code> and <code>B</code> have different types, and so the code generated for the loop is different. In order to execute a program, Finch builds a typed AST (Abstract Syntax Tree), then calls <code>Finch.execute</code> on it. The AST object is just an instance of a program to execute, and contains the program to execute along with the data to execute it. The type of the program instance contains only the program portion; there may be many program instances with different inputs, but the same program type. During compilation, Finch uses the type of the program to construct a more ergonomic representation, which is then used to generate code. This process is called &quot;virtualization&quot;.  All of the Finch AST nodes have both instance and virtual representations. For example, the literal <code>42</code> is represented as <code>Finch.FinchNotation.LiteralInstance(42)</code> and then virtualized to <code>literal(42)</code>. The virtualization process is implemented by the <code>virtualize</code> function. </p><pre><code class="language-julia-repl hljs">julia&gt; A = Fiber!(SparseList(Element(0)), [0, 2, 0, 0, 3]);

julia&gt; B = Fiber!(Dense(Element(0)), [11, 12, 13, 14, 15]);

julia&gt; s = Scalar(0);

julia&gt; typeof(A)
Fiber{SparseListLevel{Int64, Vector{Int64}, Vector{Int64}, ElementLevel{0, Int64, Int64, Vector{Int64}}}}

julia&gt; typeof(B)
Fiber{DenseLevel{Int64, ElementLevel{0, Int64, Int64, Vector{Int64}}}}

julia&gt; inst = Finch.@finch_program_instance begin
           for i = _
               s[] += A[i]
           end
       end
loop_instance(index_instance(i), Finch.FinchNotation.Dimensionless(), assign_instance(access_instance(tag_instance(:variable_instance(:s), Scalar{0, Int64}(0)), literal_instance(Finch.FinchNotation.Updater()), ), tag_instance(:variable_instance(:+), literal_instance(+)), access_instance(tag_instance(:variable_instance(:A), Fiber(SparseList{Int64}(Element{0, Int64, Int64}([2, 3]), 5, [1, 3], [2, 5]))), literal_instance(Finch.FinchNotation.Reader()), tag_instance(:variable_instance(:i), index_instance(i)))))

julia&gt; typeof(inst)
Finch.FinchNotation.LoopInstance{Finch.FinchNotation.IndexInstance{:i}, Finch.FinchNotation.Dimensionless, Finch.FinchNotation.AssignInstance{Finch.FinchNotation.AccessInstance{Finch.FinchNotation.TagInstance{Finch.FinchNotation.VariableInstance{:s}, Scalar{0, Int64}}, Finch.FinchNotation.LiteralInstance{Finch.FinchNotation.Updater()}, Tuple{}}, Finch.FinchNotation.TagInstance{Finch.FinchNotation.VariableInstance{:+}, Finch.FinchNotation.LiteralInstance{+}}, Finch.FinchNotation.AccessInstance{Finch.FinchNotation.TagInstance{Finch.FinchNotation.VariableInstance{:A}, Fiber{SparseListLevel{Int64, Vector{Int64}, Vector{Int64}, ElementLevel{0, Int64, Int64, Vector{Int64}}}}}, Finch.FinchNotation.LiteralInstance{Finch.FinchNotation.Reader()}, Tuple{Finch.FinchNotation.TagInstance{Finch.FinchNotation.VariableInstance{:i}, Finch.FinchNotation.IndexInstance{:i}}}}}}

julia&gt; Finch.virtualize(:inst, typeof(inst), Finch.JuliaContext())
for i = virtual(Finch.FinchNotation.Dimensionless)
  tag(s, virtual(Finch.VirtualScalar))[] &lt;&lt;tag(+, +)&gt;&gt;= tag(A, virtual(Finch.VirtualFiber{Finch.VirtualSparseListLevel}))[tag(i, i)]
end

julia&gt; @finch_code begin
           for i = _
               s[] += A[i]
           end
       end
quote
    s = ex.body.lhs.tns.bind
    s_val = s.val
    A_lvl = ex.body.rhs.tns.bind.lvl
    A_lvl_ptr = A_lvl.ptr
    A_lvl_idx = A_lvl.idx
    A_lvl_val = A_lvl.lvl.val
    A_lvl_q = A_lvl_ptr[1]
    A_lvl_q_stop = A_lvl_ptr[1 + 1]
    if A_lvl_q &lt; A_lvl_q_stop
        A_lvl_i1 = A_lvl_idx[A_lvl_q_stop - 1]
    else
        A_lvl_i1 = 0
    end
    phase_stop = min(A_lvl_i1, A_lvl.shape)
    if phase_stop &gt;= 1
        i = 1
        if A_lvl_idx[A_lvl_q] &lt; 1
            A_lvl_q = Finch.scansearch(A_lvl_idx, 1, A_lvl_q, A_lvl_q_stop - 1)
        end
        while i &lt;= phase_stop
            A_lvl_i = A_lvl_idx[A_lvl_q]
            phase_stop_2 = min(phase_stop, A_lvl_i)
            if A_lvl_i == phase_stop_2
                A_lvl_2_val = A_lvl_val[A_lvl_q]
                s_val = A_lvl_2_val + s_val
                A_lvl_q += 1
            end
            i = phase_stop_2 + 1
        end
    end
    (s = (Scalar){0, Int64}(s_val),)
end

julia&gt; @finch_code begin
           for i = _
               s[] += B[i]
           end
       end
quote
    s = ex.body.lhs.tns.bind
    s_val = s.val
    B_lvl = ex.body.rhs.tns.bind.lvl
    B_lvl_val = B_lvl.lvl.val
    for i_3 = 1:B_lvl.shape
        B_lvl_q = (1 - 1) * B_lvl.shape + i_3
        B_lvl_2_val = B_lvl_val[B_lvl_q]
        s_val = B_lvl_2_val + s_val
    end
    (s = (Scalar){0, Int64}(s_val),)
end</code></pre><p>Users can also create their own virtual nodes to represent their custom types. These types may contain constants and other virtuals, as well as reference variables in the scope of the executing context. Any aspect of virtuals visible to Finch should be considered immutable, but virtuals may reference mutable variables in the scope of the executing context.</p><h2 id="Fiber-internals"><a class="docs-heading-anchor" href="#Fiber-internals">Fiber internals</a><a id="Fiber-internals-1"></a><a class="docs-heading-anchor-permalink" href="#Fiber-internals" title="Permalink"></a></h2><p>Fiber levels are implemented using the following methods:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.default" href="#Finch.default"><code>Finch.default</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">default(arr)</code></pre><p>Return the initializer for <code>arr</code>. For SparseArrays, this is 0. Often, the <code>default</code> value becomes the <code>fill</code> or <code>background</code> value of a tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/62790906329fb8dda102ad392c159be852315880/src/semantics.jl#L95-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.declare_level!" href="#Finch.declare_level!"><code>Finch.declare_level!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">declare_level!(lvl, ctx, pos, init)</code></pre><p>Initialize and thaw all fibers within <code>lvl</code>, assuming positions <code>1:pos</code> were previously assembled and frozen. The resulting level has no assembled positions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/62790906329fb8dda102ad392c159be852315880/src/tensors/levels/abstractlevel.jl#L57-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.assemble_level!" href="#Finch.assemble_level!"><code>Finch.assemble_level!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assemble_level!(lvl, ctx, pos, new_pos)</code></pre><p>Assemble and positions <code>pos+1:new_pos</code> in <code>lvl</code>, assuming positions <code>1:pos</code> were previously assembled.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/62790906329fb8dda102ad392c159be852315880/src/tensors/levels/abstractlevel.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.reassemble_level!" href="#Finch.reassemble_level!"><code>Finch.reassemble_level!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reassemble_level!(lvl, ctx, pos_start, pos_end)</code></pre><p>Set the previously assempled positions from <code>pos_start</code> to <code>pos_end</code> to <code>level_default(lvl)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/62790906329fb8dda102ad392c159be852315880/src/tensors/levels/abstractlevel.jl#L73-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.freeze_level!" href="#Finch.freeze_level!"><code>Finch.freeze_level!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">freeze_level!(lvl, ctx, pos)</code></pre><p>Freeze all fibers in <code>lvl</code>. Positions <code>1:pos</code> need freezing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/62790906329fb8dda102ad392c159be852315880/src/tensors/levels/abstractlevel.jl#L81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.level_ndims" href="#Finch.level_ndims"><code>Finch.level_ndims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">level_ndims(::Type{Lvl})</code></pre><p>The result of <code>level_ndims(Lvl)</code> defines <a href="https://docs.julialang.org/en/v1/base/arrays/#Base.ndims">ndims</a> for all subfibers in a level of type <code>Lvl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/62790906329fb8dda102ad392c159be852315880/src/tensors/levels/abstractlevel.jl#L16-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.level_size" href="#Finch.level_size"><code>Finch.level_size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">level_size(lvl)</code></pre><p>The result of <code>level_size(lvl)</code> defines the <a href="https://docs.julialang.org/en/v1/base/arrays/#Base.size">size</a> of all subfibers in the level <code>lvl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/62790906329fb8dda102ad392c159be852315880/src/tensors/levels/abstractlevel.jl#L24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.level_axes" href="#Finch.level_axes"><code>Finch.level_axes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">level_axes(lvl)</code></pre><p>The result of <code>level_axes(lvl)</code> defines the <a href="https://docs.julialang.org/en/v1/base/arrays/#Base.axes-Tuple{Any}">axes</a> of all subfibers in the level <code>lvl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/62790906329fb8dda102ad392c159be852315880/src/tensors/levels/abstractlevel.jl#L32-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.level_eltype" href="#Finch.level_eltype"><code>Finch.level_eltype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">level_eltype(::Type{Lvl})</code></pre><p>The result of <code>level_eltype(Lvl)</code> defines <a href="https://docs.julialang.org/en/v1/base/collections/#Base.eltype"><code>eltype</code></a> for all subfibers in a level of type <code>Lvl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/62790906329fb8dda102ad392c159be852315880/src/tensors/levels/abstractlevel.jl#L40-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Finch.level_default" href="#Finch.level_default"><code>Finch.level_default</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">level_default(::Type{Lvl})</code></pre><p>The result of <code>level_default(Lvl)</code> defines <a href="#Finch.default"><code>default</code></a> for all subfibers in a level of type <code>Lvl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/62790906329fb8dda102ad392c159be852315880/src/tensors/levels/abstractlevel.jl#L49-L54">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../performance/">« Performance Tips</a><a class="docs-footer-nextpage" href="../directory_structure/">Directory Structure »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Monday 30 October 2023 18:40">Monday 30 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
