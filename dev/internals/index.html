<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · Finch.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://willow-ahrens.github.io/Finch.jl/internals/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Finch.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Finch.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../usage/">Usage</a></li><li><a class="tocitem" href="../fibers/">Array Formats</a></li><li><a class="tocitem" href="../algebra/">Custom Functions</a></li><li><a class="tocitem" href="../fileio/">Tensor File I/O</a></li><li><a class="tocitem" href="../interop/">C, C++, ...</a></li><li><a class="tocitem" href="../performance/">Performance Tips</a></li><li class="is-active"><a class="tocitem" href>Internals</a><ul class="internal"><li><a class="tocitem" href="#Finch-Compilation-Pipeline"><span>Finch Compilation Pipeline</span></a></li><li><a class="tocitem" href="#Finch-Notation"><span>Finch Notation</span></a></li><li><a class="tocitem" href="#Virtualization"><span>Virtualization</span></a></li><li><a class="tocitem" href="#Tensor-Life-Cycle"><span>Tensor Life Cycle</span></a></li><li><a class="tocitem" href="#Fiber-internals"><span>Fiber internals</span></a></li><li><a class="tocitem" href="#Debugging-Functionality"><span>Debugging Functionality</span></a></li></ul></li><li><a class="tocitem" href="../directory_structure/">Directory Structure</a></li><li><a class="tocitem" href="../CONTRIBUTING/">Contributing</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../benchmark/">Benchmarking</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/willow-ahrens/Finch.jl/blob/main/docs/src/internals.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Finch-Compilation-Pipeline"><a class="docs-heading-anchor" href="#Finch-Compilation-Pipeline">Finch Compilation Pipeline</a><a id="Finch-Compilation-Pipeline-1"></a><a class="docs-heading-anchor-permalink" href="#Finch-Compilation-Pipeline" title="Permalink"></a></h2><h2 id="Finch-Notation"><a class="docs-heading-anchor" href="#Finch-Notation">Finch Notation</a><a id="Finch-Notation-1"></a><a class="docs-heading-anchor-permalink" href="#Finch-Notation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.FinchNode" href="#Finch.FinchNotation.FinchNode"><code>Finch.FinchNotation.FinchNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FinchNode</code></pre><p>A Finch IR node. Finch uses a variant of Concrete Index Notation as an intermediate representation. </p><p>The FinchNode struct represents many different Finch IR nodes. The nodes are differentiated by a <code>FinchNotation.FinchNodeKind</code> enum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/FinchNotation/nodes.jl#L193-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.literal" href="#Finch.FinchNotation.literal"><code>Finch.FinchNotation.literal</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">literal(val)</code></pre><p>Finch AST expression for the literal value <code>val</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/FinchNotation/nodes.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.index" href="#Finch.FinchNotation.index"><code>Finch.FinchNotation.index</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">index(name)</code></pre><p>Finch AST expression for an index named <code>name</code>. Each index must be quantified by a corresponding <code>loop</code> which iterates over all values of the index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/FinchNotation/nodes.jl#L60-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.variable" href="#Finch.FinchNotation.variable"><code>Finch.FinchNotation.variable</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">variable(name)</code></pre><p>Finch AST expression for a variable named <code>name</code>. The variable can be looked up in the context.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/FinchNotation/nodes.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.virtual" href="#Finch.FinchNotation.virtual"><code>Finch.FinchNotation.virtual</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">virtual(val)</code></pre><p>Finch AST expression for an object <code>val</code> which has special meaning to the compiler. This type allows users to substitute their own ASTs, etc. into Finch expressions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/FinchNotation/nodes.jl#L38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.value" href="#Finch.FinchNotation.value"><code>Finch.FinchNotation.value</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">value(val, type)</code></pre><p>Finch AST expression for host code <code>val</code> expected to evaluate to a value of type <code>type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/FinchNotation/nodes.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.loop" href="#Finch.FinchNotation.loop"><code>Finch.FinchNotation.loop</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">loop(idx, ext, body)</code></pre><p>Finch AST statement that runs <code>body</code> for each value of <code>idx</code> in <code>ext</code>. Tensors in <code>body</code> must have ranges that agree with <code>ext</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/FinchNotation/nodes.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.assign" href="#Finch.FinchNotation.assign"><code>Finch.FinchNotation.assign</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">assign(lhs, op, rhs)</code></pre><p>Finch AST statement that updates the value of <code>lhs</code> to <code>op(lhs, rhs)</code>. The tensors of <code>lhs</code> are returned.  Overwriting is accomplished with the function <code>right(lhs, rhs) = rhs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/FinchNotation/nodes.jl#L147-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.call" href="#Finch.FinchNotation.call"><code>Finch.FinchNotation.call</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">call(op, args...)</code></pre><p>Finch AST expression for the result of calling the function <code>op</code> on <code>args...</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/FinchNotation/nodes.jl#L125-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.cached" href="#Finch.FinchNotation.cached"><code>Finch.FinchNotation.cached</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">cached(val, ref)</code></pre><p>Finch AST expression <code>val</code>, equivalent to the quoted expression <code>ref</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/FinchNotation/nodes.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.reader" href="#Finch.FinchNotation.reader"><code>Finch.FinchNotation.reader</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">reader()</code></pre><p>Finch AST expression for an access mode that is read-only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/FinchNotation/nodes.jl#L92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.updater" href="#Finch.FinchNotation.updater"><code>Finch.FinchNotation.updater</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">updater(mode)</code></pre><p>Finch AST expression for an access mode that may modify the tensor. The <code>mode</code> field specifies whether this access returns this tensor (initializing and finalizing) or modifies it in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/FinchNotation/nodes.jl#L99-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.create" href="#Finch.FinchNotation.create"><code>Finch.FinchNotation.create</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">create()</code></pre><p>Finch AST expression for an &quot;allocating&quot; update. This access will initialize and freeze the tensor, and we can be sure that any values the tensor held before have been forgotten.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/FinchNotation/nodes.jl#L108-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.modify" href="#Finch.FinchNotation.modify"><code>Finch.FinchNotation.modify</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">modify()</code></pre><p>Finch AST expression for an &quot;in place&quot; update. The access will not initialize or freeze the tensor, but can modify it&#39;s existing values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/FinchNotation/nodes.jl#L117-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.declare" href="#Finch.FinchNotation.declare"><code>Finch.FinchNotation.declare</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">declare(tns, init)</code></pre><p>Finch AST statement that declares <code>tns</code> with an initial value <code>init</code> in the current scope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/FinchNotation/nodes.jl#L156-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.freeze" href="#Finch.FinchNotation.freeze"><code>Finch.FinchNotation.freeze</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">freeze(tns)</code></pre><p>Finch AST statement that freezes <code>tns</code> in the current scope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/FinchNotation/nodes.jl#L163-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.thaw" href="#Finch.FinchNotation.thaw"><code>Finch.FinchNotation.thaw</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">thaw(tns)</code></pre><p>Finch AST statement that thaws <code>tns</code> in the current scope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/FinchNotation/nodes.jl#L170-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.forget" href="#Finch.FinchNotation.forget"><code>Finch.FinchNotation.forget</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">forget(tns)</code></pre><p>Finch AST statement that marks the end of the lifetime of <code>tns</code>, at least until it is declared again.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/FinchNotation/nodes.jl#L177-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.access" href="#Finch.FinchNotation.access"><code>Finch.FinchNotation.access</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">access(tns, mode, idx...)</code></pre><p>Finch AST expression representing the value of tensor <code>tns</code> at the indices <code>idx...</code>. The <code>mode</code> differentiates between reads or updates and whether the access is in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/FinchNotation/nodes.jl#L83-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.sequence" href="#Finch.FinchNotation.sequence"><code>Finch.FinchNotation.sequence</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">sequence(bodies...)</code></pre><p>Finch AST statement that executes each of it&#39;s arguments in turn. If the body is not a sequence, replaces accesses to read-only tensors in the body with get<em>reader and accesses to update-only tensors in the body with get</em>updater.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/FinchNotation/nodes.jl#L184-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.protocol" href="#Finch.FinchNotation.protocol"><code>Finch.FinchNotation.protocol</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">protocol(idx, mode)</code></pre><p>Finch AST expression marking an indexing expression <code>idx</code> with the protocol <code>mode</code>. These usually reside at the toplevel of an indexing expression to an access.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/FinchNotation/nodes.jl#L75-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.sieve" href="#Finch.FinchNotation.sieve"><code>Finch.FinchNotation.sieve</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">sieve(cond, body)</code></pre><p>Finch AST statement that only executes <code>body</code> if <code>cond</code> is true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/FinchNotation/nodes.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.finch_leaf" href="#Finch.FinchNotation.finch_leaf"><code>Finch.FinchNotation.finch_leaf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">finch_leaf(x)</code></pre><p>Return a terminal finch node wrapper around <code>x</code>. A convenience function to determine whether <code>x</code> should be understood by default as a literal, value, or virtual.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/FinchNotation/nodes.jl#L739-L745">source</a></section></article><h3 id="Program-Instances"><a class="docs-heading-anchor" href="#Program-Instances">Program Instances</a><a id="Program-Instances-1"></a><a class="docs-heading-anchor-permalink" href="#Program-Instances" title="Permalink"></a></h3><p>Finch relies heavily on Julia&#39;s <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/">metaprogramming capabilities</a> ( <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/#Macros">macros</a> and <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/#Generated-functions">generated functions</a> in particular) to produce code. To review briefly, a macro allows us to inspect the syntax of it&#39;s arguments and generate replacement syntax. A generated function allows us to inspect the type of the function arguments and produce code for a function body.</p><p>In normal Finch usage, we might call Finch as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; C = @fiber(sl(e(0)));

julia&gt; A = @fiber(sl(e(0)), [0, 2, 0, 0, 3]);

julia&gt; B = @fiber(d(e(0)), [11, 12, 13, 14, 15]);

julia&gt; @finch (C .= 0; @loop i C[i] = A[i] * B[i]);

julia&gt; C
SparseList (0) [1:5]
├─[2]: 24
├─[5]: 45</code></pre><p>The <a href="https://docs.julialang.org/en/v1/base/base/#Base.macroexpand"><code>@macroexpand</code></a> macro allows us to see the result of applying a macro. Let&#39;s examine what happens when we use the <code>@finch</code> macro (we&#39;ve stripped line numbers from the result to clean it up):</p><pre><code class="language-julia-repl hljs">julia&gt; (@macroexpand @finch (C .= 0; @loop i C[i] = A[i] * B[i])) |&gt; Finch.striplines |&gt; Finch.regensym
quote
    _res_1 = (Finch.execute)((Finch.FinchNotation.sequence_instance)((Finch.FinchNotation.declare_instance)((Finch.FinchNotation.variable_instance)(:C, (Finch.FinchNotation.finch_leaf_instance)(C)), literal_instance(0)), begin
                    let i = index_instance(i)
                        (Finch.FinchNotation.loop_instance)(i, index_instance(:), (Finch.FinchNotation.assign_instance)((Finch.FinchNotation.access_instance)((Finch.FinchNotation.variable_instance)(:C, (Finch.FinchNotation.finch_leaf_instance)(C)), (Finch.FinchNotation.updater_instance)((Finch.FinchNotation.create_instance)()), (Finch.FinchNotation.variable_instance)(:i, (Finch.FinchNotation.finch_leaf_instance)(i))), (Finch.FinchNotation.literal_instance)((Finch.FinchNotation.initwrite)((Finch.default)(C))), (Finch.FinchNotation.call_instance)((Finch.FinchNotation.variable_instance)(:*, (Finch.FinchNotation.finch_leaf_instance)(*)), (Finch.FinchNotation.access_instance)((Finch.FinchNotation.variable_instance)(:A, (Finch.FinchNotation.finch_leaf_instance)(A)), (Finch.FinchNotation.reader_instance)(), (Finch.FinchNotation.variable_instance)(:i, (Finch.FinchNotation.finch_leaf_instance)(i))), (Finch.FinchNotation.access_instance)((Finch.FinchNotation.variable_instance)(:B, (Finch.FinchNotation.finch_leaf_instance)(B)), (Finch.FinchNotation.reader_instance)(), (Finch.FinchNotation.variable_instance)(:i, (Finch.FinchNotation.finch_leaf_instance)(i))))))
                    end
                end))
    begin
        C = Finch.get(_res_1, :C, C)
    end
    begin
        _res_1
    end
end
</code></pre><p>In the above output, <code>@finch</code> creates an AST of program instances, then calls <code>Finch.execute</code> on it. A program instance is a struct that contains the program to be executed along with its arguments. Although we can use the above constructors (e.g. <code>loop_instance</code>) to make our own program instance, it is most convenient to use the unexported macro <code>Finch.finch_program_instance</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; using Finch: @finch_program_instance

julia&gt; prgm = Finch.@finch_program_instance (C .= 0; @loop i C[i] = A[i] * B[i])
sequence_instance(declare_instance(variable_instance(:C, C), literal_instance(0)), loop_instance(index_instance(i), index_instance(:), assign_instance(access_instance(variable_instance(:C, C), updater_instance(create_instance()), index_instance(i)), literal_instance(Finch.FinchNotation.InitWriter{0}()), call_instance(variable_instance(:*, *), access_instance(variable_instance(:A, A), reader_instance(), index_instance(i)), access_instance(variable_instance(:B, B), reader_instance(), index_instance(i))))))</code></pre><p>As we can see, our program instance contains not only the AST to be executed, but also the data to execute the program with. The type of the program instance contains only the program portion; there may be many program instances with different inputs, but the same program type. We can run our program using <code>Finch.execute</code>, which returns a <code>NamedTuple</code> of outputs.</p><pre><code class="language-julia-repl hljs">julia&gt; typeof(prgm)
Finch.FinchNotation.SequenceInstance{Tuple{Finch.FinchNotation.DeclareInstance{Finch.FinchNotation.VariableInstance{:C, Fiber{SparseListLevel{Int64, Int64, ElementLevel{0, Int64}}}}, Finch.FinchNotation.LiteralInstance{0}}, Finch.FinchNotation.LoopInstance{Finch.FinchNotation.IndexInstance{:i}, Finch.FinchNotation.IndexInstance{:(:)}, Finch.FinchNotation.AssignInstance{Finch.FinchNotation.AccessInstance{Finch.FinchNotation.VariableInstance{:C, Fiber{SparseListLevel{Int64, Int64, ElementLevel{0, Int64}}}}, Finch.FinchNotation.UpdaterInstance{Finch.FinchNotation.CreateInstance}, Tuple{Finch.FinchNotation.IndexInstance{:i}}}, Finch.FinchNotation.LiteralInstance{Finch.FinchNotation.InitWriter{0}()}, Finch.FinchNotation.CallInstance{Finch.FinchNotation.VariableInstance{:*, Finch.FinchNotation.LiteralInstance{*}}, Tuple{Finch.FinchNotation.AccessInstance{Finch.FinchNotation.VariableInstance{:A, Fiber{SparseListLevel{Int64, Int64, ElementLevel{0, Int64}}}}, Finch.FinchNotation.ReaderInstance, Tuple{Finch.FinchNotation.IndexInstance{:i}}}, Finch.FinchNotation.AccessInstance{Finch.FinchNotation.VariableInstance{:B, Fiber{DenseLevel{Int64, ElementLevel{0, Int64}}}}, Finch.FinchNotation.ReaderInstance, Tuple{Finch.FinchNotation.IndexInstance{:i}}}}}}}}}

julia&gt; C = Finch.execute(prgm).C
SparseList (0) [1:5]
├─[2]: 24
├─[5]: 45</code></pre><p>This functionality is sufficient for building finch kernels programatically. For example, if we wish to define a function <code>pointwise_sum()</code> that takes the pointwise sum of a variable number of vector inputs, we might implement it as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; function pointwise_sum(As...)
           B = @fiber(d(e(0)))
           isempty(As) &amp;&amp; return B
           i = Finch.FinchNotation.index_instance(:i)
           A_vars = [Finch.FinchNotation.variable_instance(Symbol(:A, n), As[n]) for n in 1:length(As)]
           #create a list of variable instances with different names to hold the input tensors
           ex = @finch_program_instance 0
           for A_var in A_vars
               ex = @finch_program_instance $A_var[i] + $ex
           end
           prgm = @finch_program_instance (B .= 0; @loop i B[i] = $ex)
           return Finch.execute(prgm).B
       end
pointwise_sum (generic function with 1 method)

julia&gt; pointwise_sum([1, 2], [3, 4])
Dense [1:2]
├─[1]: 4
├─[2]: 6
</code></pre><h2 id="Virtualization"><a class="docs-heading-anchor" href="#Virtualization">Virtualization</a><a id="Virtualization-1"></a><a class="docs-heading-anchor-permalink" href="#Virtualization" title="Permalink"></a></h2><p>TODO more on the way...</p><h2 id="Tensor-Life-Cycle"><a class="docs-heading-anchor" href="#Tensor-Life-Cycle">Tensor Life Cycle</a><a id="Tensor-Life-Cycle-1"></a><a class="docs-heading-anchor-permalink" href="#Tensor-Life-Cycle" title="Permalink"></a></h2><p>Every virtual tensor must be in one of two modes: read-only mode or update-only mode. The following functions may be called on virtual tensors throughout their life cycle.</p><article class="docstring"><header><a class="docstring-binding" id="Finch.declare!" href="#Finch.declare!"><code>Finch.declare!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">declare!(tns, ctx, init)</code></pre><p>Declare the read-only virtual tensor <code>tns</code> in the context <code>ctx</code> with a starting value of <code>init</code> and return it. Afterwards the tensor is update-only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/semantics.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.get_reader" href="#Finch.get_reader"><code>Finch.get_reader</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_reader(tns, ctx, protos...)</code></pre><p>Return an object (usually a looplet nest) capable of reading the read-only virtual tensor <code>tns</code>.  As soon as a read-only tensor enters scope, each subsequent read access will be initialized with a separate call to <code>get_reader</code>. <code>protos</code> is the list of protocols in each case.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/semantics.jl#L9-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.get_updater" href="#Finch.get_updater"><code>Finch.get_updater</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_updater(tns, ctx, protos...)</code></pre><p>Return an object (usually a looplet nest) capable of updating the update-only virtual tensor <code>tns</code>.  As soon as an update only tensor enters scope, each subsequent update access will be initialized with a separate call to <code>get_updater</code>.  <code>protos</code> is the list of protocols in each case.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/semantics.jl#L19-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.freeze!" href="#Finch.freeze!"><code>Finch.freeze!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">freeze!(tns, ctx)</code></pre><p>Freeze the update-only virtual tensor <code>tns</code> in the context <code>ctx</code> and return it. Afterwards, the tensor is read-only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/semantics.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.trim!" href="#Finch.trim!"><code>Finch.trim!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">trim!(tns, ctx)</code></pre><p>Before returning a tensor from the finch program, trim any excess overallocated memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/semantics.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.thaw!" href="#Finch.thaw!"><code>Finch.thaw!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">thaw!(tns, ctx)</code></pre><p>Thaw the read-only virtual tensor <code>tns</code> in the context <code>ctx</code> and return it. Afterwards, the tensor is update-only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/semantics.jl#L37-L42">source</a></section></article><h2 id="Fiber-internals"><a class="docs-heading-anchor" href="#Fiber-internals">Fiber internals</a><a id="Fiber-internals-1"></a><a class="docs-heading-anchor-permalink" href="#Fiber-internals" title="Permalink"></a></h2><p>Fiber levels are implemented using the following methods:</p><article class="docstring"><header><a class="docstring-binding" id="Finch.default" href="#Finch.default"><code>Finch.default</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">default(arr)</code></pre><p>Return the initializer for <code>arr</code>. For SparseArrays, this is 0. Often, the <code>default</code> value becomes the <code>fill</code> or <code>background</code> value of a tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/semantics.jl#L93-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.declare_level!" href="#Finch.declare_level!"><code>Finch.declare_level!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">declare_level!(lvl, ctx, pos, init)</code></pre><p>Initialize and thaw all fibers within <code>lvl</code>, assuming positions <code>1:pos</code> were previously assembled and frozen. The resulting level has no assembled positions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/tensors/fibers.jl#L112-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.assemble_level!" href="#Finch.assemble_level!"><code>Finch.assemble_level!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assemble_level!(lvl, ctx, pos, new_pos)</code></pre><p>Assemble and positions <code>pos+1:new_pos</code> in <code>lvl</code>, assuming positions <code>1:pos</code> were previously assembled.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/tensors/fibers.jl#L120-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.reassemble_level!" href="#Finch.reassemble_level!"><code>Finch.reassemble_level!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reassemble_level!(lvl, ctx, pos_start, pos_end)</code></pre><p>Set the previously assempled positions from <code>pos_start</code> to <code>pos_end</code> to <code>level_default(lvl)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/tensors/fibers.jl#L128-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.freeze_level!" href="#Finch.freeze_level!"><code>Finch.freeze_level!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">freeze_level!(lvl, ctx, pos)</code></pre><p>Freeze all fibers in <code>lvl</code>. Positions <code>1:pos</code> need freezing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/tensors/fibers.jl#L136-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.level_ndims" href="#Finch.level_ndims"><code>Finch.level_ndims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">level_ndims(::Type{Lvl})</code></pre><p>The result of <code>level_ndims(Lvl)</code> defines <a href="https://docs.julialang.org/en/v1/base/arrays/#Base.ndims">ndims</a> for all subfibers in a level of type <code>Lvl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/tensors/fibers.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.level_size" href="#Finch.level_size"><code>Finch.level_size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">level_size(lvl)</code></pre><p>The result of <code>level_size(lvl)</code> defines the <a href="https://docs.julialang.org/en/v1/base/arrays/#Base.size">size</a> of all subfibers in the level <code>lvl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/tensors/fibers.jl#L62-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.level_axes" href="#Finch.level_axes"><code>Finch.level_axes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">level_axes(lvl)</code></pre><p>The result of <code>level_axes(lvl)</code> defines the <a href="https://docs.julialang.org/en/v1/base/arrays/#Base.axes-Tuple{Any}">axes</a> of all subfibers in the level <code>lvl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/tensors/fibers.jl#L71-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.level_eltype" href="#Finch.level_eltype"><code>Finch.level_eltype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">level_eltype(::Type{Lvl})</code></pre><p>The result of <code>level_eltype(Lvl)</code> defines <a href="https://docs.julialang.org/en/v1/base/collections/#Base.eltype"><code>eltype</code></a> for all subfibers in a level of type <code>Lvl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/tensors/fibers.jl#L80-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.level_default" href="#Finch.level_default"><code>Finch.level_default</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">level_default(::Type{Lvl})</code></pre><p>The result of <code>level_default(Lvl)</code> defines <a href="#Finch.default"><code>default</code></a> for all subfibers in a level of type <code>Lvl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/tensors/fibers.jl#L91-L96">source</a></section></article><h2 id="Debugging-Functionality"><a class="docs-heading-anchor" href="#Debugging-Functionality">Debugging Functionality</a><a id="Debugging-Functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Debugging-Functionality" title="Permalink"></a></h2><p>It&#39;s easy to ask Finch to advance a few steps in its compiler pipeline. The basic functionality is documented via the following bit of code:</p><pre><code class="nohighlight hljs">using Finch
using Finch: @finch_program_instance, begin_debug, step_code, iscompiled, end_debug

y = @fiber d(e(0.0))
A = @fiber d(sl(e(0.0)))
x = @fiber sl(e(0.0))

code = Finch.@finch_program_instance begin
   @loop j i y[i] += A[i, j] * x[j]
end

debug = begin_debug(code)

while true
    global debug = step_code(debug) # Runs one step of compilation
    if iscompiled(debug.code) # Checks if we are done compiling.
        break
    end
end
        
ret = end_debug(debug) # extracts code from debugging context.
# Prints compiled code</code></pre><p>The function <code>begin_debug(code; algebra)</code> takes a <code>finch_program_instance</code> plus an optional algebra and creates a debugging context for it, called a <code>PartialCode</code>. The function <code>step_code(debug; steps, sdisplay)</code> takes a debugging  context and advances some number of <code>steps</code>, displaying the results automatically if <code>sdisplay</code>. Finally, <code>iscompiled</code> checks if the code in a debug context is completely compiled and <code>end_debug</code> extracts the code, throwing an error if the code is not completely compiled.</p><article class="docstring"><header><a class="docstring-binding" id="Finch.begin_debug" href="#Finch.begin_debug"><code>Finch.begin_debug</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">begin_debug(code; algebra = DefaultAlgebra(), sdisplay=false)</code></pre><p>Takes a Finch Program and stages it within a DebugContext, defined within a particualr algebra.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/resumables.jl#L262-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.step_code" href="#Finch.step_code"><code>Finch.step_code</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">step_code(code::PartialCode; step=1, sdisplay=false)</code></pre><p>Advance the compiler on <code>code</code> for <code>step</code>, displaying the code at the end if <code>sdisplay</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/resumables.jl#L305-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.iscompiled" href="#Finch.iscompiled"><code>Finch.iscompiled</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iscompiled(code:: Expr)</code></pre><p>Checks if Julia AST has any Resumables in it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/resumables.jl#L316-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.end_debug" href="#Finch.end_debug"><code>Finch.end_debug</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">end_debug(code:: PartialCode)</code></pre><p>Returns a finished Julia AST from a <code>PartialCode</code>` if it has no Resumables in it. Throws an error otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/resumables.jl#L332-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.PartialCode" href="#Finch.PartialCode"><code>Finch.PartialCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PartialCode(lastControl :: AbstractLoweringControl, code)</code></pre><p>Essentially a debugging context that holds the code that we are working on and the <code>AbstractLoweringControl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/resumables.jl#L230-L234">source</a></section></article><p>Partially compiled code will be displayed almost like fully compiled code but with <code>@finch</code> nodes that are numbered according to which will be compiled first. They also display where they will renter the compilation pipeline.  An early step in the above program might look like:</p><pre><code class="nohighlight hljs">quote
    y_lvl = ex.body.body.lhs.tns.tns.lvl
    y_lvl_2 = y_lvl.lvl
    A_lvl = (ex.body.body.rhs.args[1]).tns.tns.lvl
    A_lvl_2 = A_lvl.lvl
    A_lvl_3 = A_lvl_2.lvl
    x_lvl = (ex.body.body.rhs.args[2]).tns.tns.lvl
    x_lvl_2 = x_lvl.lvl
    y_lvl.shape == A_lvl_2.shape || throw(DimensionMismatch(&quot;mismatched dimension limits ($(y_lvl.shape) != $(@finch((Number = 0, Which = (&quot;lower.jl&quot;, 174))A_lvl_2.shape::Int64)))&quot;))
    @finch((Number = 1, Which = (&quot;lower.jl&quot;, 174))A_lvl.shape::Int64) == @finch((Number = 2, Which = (&quot;lower.jl&quot;, 174))x_lvl.shape::Int64) || throw(DimensionMismatch(&quot;mismatched dimension limits ($(@finch((Number = 3, Which = (&quot;lower.jl&quot;, 174))A_lvl.shape::Int64)) != $(@finch((Number = 4, Which = (&quot;lower.jl&quot;, 174))x_lvl.shape::Int64)))&quot;))
    @finch begin(Number = 5, Which = (&quot;lower.jl&quot;, 174))
      begin
        @thaw(y)
        @∀ j = virtual(Finch.Extent) i = virtual(Finch.Extent)  (
          y[i] &lt;&lt;+&gt;&gt;= *(x[j], A[i, j])        )
        @freeze(y)
      end
    end
    qos = @finch((Number = 6, Which = (&quot;lower.jl&quot;, 174))1) * @finch((Number = 7, Which = (&quot;lower.jl&quot;, 174))y_lvl.shape::Int64)
    resize!(y_lvl_2.val, @finch((Number = 8, Which = (&quot;lower.jl&quot;, 174))qos))
    (y = @finch((Number = 9, Which = (&quot;fibers.jl&quot;, 27))VirtualFiber(d(e(0.0)))),)
end</code></pre><h3 id="Dangers"><a class="docs-heading-anchor" href="#Dangers">Dangers</a><a id="Dangers-1"></a><a class="docs-heading-anchor-permalink" href="#Dangers" title="Permalink"></a></h3><p>This feature is experimental and could easily break. In particular, this feature assumes that the Finch compiler never produces  code that is needed to produce the next bit of code without putting the required analysis in the program that is being compiled. For example, we cannot currently pause</p><pre><code class="nohighlight hljs">code = ctx(A1)
info = analysis(code)
code1 = ctx(A2, info)
begin
$code1
$code2
end</code></pre><p>because analysis on the first bit of code will give the wrong results if we don&#39;t finish it,  but it would be okay to do something like this if we placed the analysis in the resulting code,  as part of the runtime.</p><p>If in the future, Finch needs to do this, this feature will break. However, there is an internal mechanism to recover. The <code>AbstractLoweringControl</code> type is supposed to manage when code is allowed to be paused via the <code>should_pause</code> function.  Modifying this function on <code>StepOnlyControl &lt;: AbstractLoweringControl</code> or creating a new control is a potential route to ensure incremental compilation does not occur when it is impossible i.e  when dependencies in the compiler mean code cannot be partially compiled.</p><article class="docstring"><header><a class="docstring-binding" id="Finch.Resumable" href="#Finch.Resumable"><code>Finch.Resumable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Resumable(ctx, root, style, meta)</code></pre><p>Struct to hold a paused compilation. Holds the compiler state in <code>ctx</code>, a FinchNode in <code>root</code>, and the compiler style in <code>style</code>. If the resumable is in an expression context. The <code>meta</code> field is a Dict of metadata about the resumable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/resumables.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.should_resume" href="#Finch.should_resume"><code>Finch.should_resume</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">should_resume(c :: AbstractLoweringControl, ctx, node, style, meta)</code></pre><p>Determines if a control wants to resume lowering a Resumable.  Should return true or false. Defaults to true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/resumables.jl#L82-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.should_pause" href="#Finch.should_pause"><code>Finch.should_pause</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">should_pause(c :: AbstractLoweringControl, ctx, node, style)</code></pre><p>Determines if a control wants to pause on a particular lowering of a particular FinchNode. Should return true or false. Defaults to false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/resumables.jl#L102-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.evolve_control" href="#Finch.evolve_control"><code>Finch.evolve_control</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evolve_control(c :: AbstractLoweringControl, ctx, node, style)</code></pre><p>In the event that control does not pause on a Finch node, we evolve the control, resulting in a new <code>AbstractLoweringControl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/resumables.jl#L123-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.init_meta" href="#Finch.init_meta"><code>Finch.init_meta</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">init_meta(c :: AbstractLoweringControl, ctx, node, style)</code></pre><p>Returns recomputed metadata for a resumable in the event that it is not resumed.  Defaults to the empty dict.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/resumables.jl#L112-L117">source</a></section></article><h3 id="Advanced-Dangers:-Non-Serial-Compilation"><a class="docs-heading-anchor" href="#Advanced-Dangers:-Non-Serial-Compilation">Advanced Dangers: Non-Serial Compilation</a><a id="Advanced-Dangers:-Non-Serial-Compilation-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Dangers:-Non-Serial-Compilation" title="Permalink"></a></h3><p>Furthermore, the Finch compiler is inhernetly serial: statements in a sequence rely on information found via compiling earlier statements. Thus, although this feature exports functions that can reorder the compilation, we do not expect these to work consistently and we leave them basically undocumented.</p><article class="docstring"><header><a class="docstring-binding" id="Finch.step_all_code" href="#Finch.step_all_code"><code>Finch.step_all_code</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">step_all_code(code::PartialCode; step=1, sdisplay=false)</code></pre><p>Experimental feature: Do not use explictly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/resumables.jl#L274-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.repeat_step_code" href="#Finch.repeat_step_code"><code>Finch.repeat_step_code</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">repeat_step_code(code::PartialCode; control=nothing, sdisplay=false)</code></pre><p>Experimental feature: Do not use explictly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/resumables.jl#L282-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.step_some_code" href="#Finch.step_some_code"><code>Finch.step_some_code</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">step_some_code(code::PartialCode; step=1, resumeLocations=nothing, resumeStyles=nothing, resumeFilter=nothing, sdisplay=false)</code></pre><p>Experimental feature: Do not use explictly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/72918bc47d639bdbb9dbb57e0d342db81216df5f/src/resumables.jl#L296-L299">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../performance/">« Performance Tips</a><a class="docs-footer-nextpage" href="../directory_structure/">Directory Structure »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 7 June 2023 15:04">Wednesday 7 June 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
