<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Semantics · Finch.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://willow-ahrens.github.io/Finch.jl/semantics/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Finch.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Finch.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../usage/">Usage</a></li><li class="is-active"><a class="tocitem" href>Semantics</a><ul class="internal"><li><a class="tocitem" href="#Finch-Notation"><span>Finch Notation</span></a></li><li class="toplevel"><a class="tocitem" href="#Scoping"><span>Scoping</span></a></li><li class="toplevel"><a class="tocitem" href="#Tensor-Lifecycle"><span>Tensor Lifecycle</span></a></li><li class="toplevel"><a class="tocitem" href="#Dimensionalization"><span>Dimensionalization</span></a></li><li class="toplevel"><a class="tocitem" href="#Array-Combinators"><span>Array Combinators</span></a></li><li class="toplevel"><a class="tocitem" href="#Fancy-Indexing"><span>Fancy Indexing</span></a></li></ul></li><li><a class="tocitem" href="../fibers/">Array Formats</a></li><li><a class="tocitem" href="../algebra/">Custom Functions</a></li><li><a class="tocitem" href="../fileio/">Tensor File I/O</a></li><li><a class="tocitem" href="../interop/">C, C++, ...</a></li><li><a class="tocitem" href="../performance/">Performance Tips</a></li><li><a class="tocitem" href="../internals/">Internals</a></li><li><a class="tocitem" href="../directory_structure/">Directory Structure</a></li><li><a class="tocitem" href="../CONTRIBUTING/">Contributing</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../benchmark/">Benchmarking</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Semantics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Semantics</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/willow-ahrens/Finch.jl/blob/main/docs/src/semantics.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Finch-Notation"><a class="docs-heading-anchor" href="#Finch-Notation">Finch Notation</a><a id="Finch-Notation-1"></a><a class="docs-heading-anchor-permalink" href="#Finch-Notation" title="Permalink"></a></h2><p>Finch programs are written in Julia, but they are not Julia programs. Instead, they are an abstraction description of a tensor computation.</p><p>Finch programs are blocks of tensor operations, joined by control flow. Finch is an imperative language. The AST is separated into statements and expressions, where statements can modify the state of the program but expressions cannot.</p><p>The core Finch expressions are:</p><ul><li><a href="@ref">literal</a> e.g. <code>1</code>, <code>1.0</code>, <code>nothing</code></li><li><a href="@ref">value</a> e.g. <code>x</code>, <code>y</code></li><li><a href="@ref">index</a> e.g. <code>i</code>, inside of <code>for i = _; ... end</code></li><li><a href="@ref">variable</a> e.g. <code>x</code>, inside of <code>(x = y; ...)</code></li><li><a href="@ref">call</a> e.g. <code>op(args...)</code></li><li><a href="@ref">access</a> e.g. <code>tns[idxs...]</code></li></ul><p>And the core Finch statements are:</p><ul><li><a href="@ref">define</a> e.g. <code>var = val</code></li><li><a href="@ref">declare</a> e.g. <code>tns .= init</code></li><li><a href="@ref">assign</a> e.g. <code>lhs[idxs...] &lt;&lt;op&gt;&gt;= rhs</code></li><li><a href="@ref">loop</a> e.g. <code>for i = _; ... end</code></li><li><a href="@ref">sieve</a> e.g. <code>if cond; ... end</code></li><li><a href="@ref">block</a> e.g. <code>begin ... end</code></li></ul><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.literal" href="#Finch.FinchNotation.literal"><code>Finch.FinchNotation.literal</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">literal(val)</code></pre><p>Finch AST expression for the literal value <code>val</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/a03c0cb8a2833ac998f963a52edd2432f8e4e0b7/src/FinchNotation/nodes.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.value" href="#Finch.FinchNotation.value"><code>Finch.FinchNotation.value</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">value(val, type)</code></pre><p>Finch AST expression for host code <code>val</code> expected to evaluate to a value of type <code>type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/a03c0cb8a2833ac998f963a52edd2432f8e4e0b7/src/FinchNotation/nodes.jl#L34-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.index" href="#Finch.FinchNotation.index"><code>Finch.FinchNotation.index</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">index(name)</code></pre><p>Finch AST expression for an index named <code>name</code>. Each index must be quantified by a corresponding <code>loop</code> which iterates over all values of the index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/a03c0cb8a2833ac998f963a52edd2432f8e4e0b7/src/FinchNotation/nodes.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.variable" href="#Finch.FinchNotation.variable"><code>Finch.FinchNotation.variable</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">variable(name)</code></pre><p>Finch AST expression for a variable named <code>name</code>. The variable can be looked up in the context.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/a03c0cb8a2833ac998f963a52edd2432f8e4e0b7/src/FinchNotation/nodes.jl#L50-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.call" href="#Finch.FinchNotation.call"><code>Finch.FinchNotation.call</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">call(op, args...)</code></pre><p>Finch AST expression for the result of calling the function <code>op</code> on <code>args...</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/a03c0cb8a2833ac998f963a52edd2432f8e4e0b7/src/FinchNotation/nodes.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.access" href="#Finch.FinchNotation.access"><code>Finch.FinchNotation.access</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">access(tns, mode, idx...)</code></pre><p>Finch AST expression representing the value of tensor <code>tns</code> at the indices <code>idx...</code>. The <code>mode</code> differentiates between reads or updates and whether the access is in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/a03c0cb8a2833ac998f963a52edd2432f8e4e0b7/src/FinchNotation/nodes.jl#L74-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.define" href="#Finch.FinchNotation.define"><code>Finch.FinchNotation.define</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">define(lhs, rhs)</code></pre><p>Finch AST statement that defines <code>lhs</code> as having the value <code>rhs</code> in the current scope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/a03c0cb8a2833ac998f963a52edd2432f8e4e0b7/src/FinchNotation/nodes.jl#L126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.assign" href="#Finch.FinchNotation.assign"><code>Finch.FinchNotation.assign</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">assign(lhs, op, rhs)</code></pre><p>Finch AST statement that updates the value of <code>lhs</code> to <code>op(lhs, rhs)</code>. Overwriting is accomplished with the function <code>overwrite(lhs, rhs) = rhs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/a03c0cb8a2833ac998f963a52edd2432f8e4e0b7/src/FinchNotation/nodes.jl#L118-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.loop" href="#Finch.FinchNotation.loop"><code>Finch.FinchNotation.loop</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">loop(idx, ext, body)</code></pre><p>Finch AST statement that runs <code>body</code> for each value of <code>idx</code> in <code>ext</code>. Tensors in <code>body</code> must have ranges that agree with <code>ext</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/a03c0cb8a2833ac998f963a52edd2432f8e4e0b7/src/FinchNotation/nodes.jl#L103-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.sieve" href="#Finch.FinchNotation.sieve"><code>Finch.FinchNotation.sieve</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">sieve(cond, body)</code></pre><p>Finch AST statement that only executes <code>body</code> if <code>cond</code> is true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/a03c0cb8a2833ac998f963a52edd2432f8e4e0b7/src/FinchNotation/nodes.jl#L111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.block" href="#Finch.FinchNotation.block"><code>Finch.FinchNotation.block</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">block(bodies...)</code></pre><p>Finch AST statement that executes each of it&#39;s arguments in turn. If the body is not a block, replaces accesses to read-only tensors in the body with instantiate<em>reader and accesses to update-only tensors in the body with instantiate</em>updater.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/a03c0cb8a2833ac998f963a52edd2432f8e4e0b7/src/FinchNotation/nodes.jl#L154-L160">source</a></section></article><h1 id="Scoping"><a class="docs-heading-anchor" href="#Scoping">Scoping</a><a id="Scoping-1"></a><a class="docs-heading-anchor-permalink" href="#Scoping" title="Permalink"></a></h1><p>Finch programs are scoped. Scopes contain variable definitions and tensor declarations.  Loops and sieves introduce new scopes. The following program has four scopes, each of which is numbered to the left of the statements it contains.</p><pre><code class="nohighlight hljs">@finch begin
1   y .= 0
1   for j = _
1   2   t .= 0
1   2   for i = _
1   2   3   t[] += A[i, j] * x[i]
1   2   end
1   2   for i = _
1   2   4   y[i] += A[i, j] * t[]
1   2   end
1   end
end</code></pre><p>Variables refer to their defined values in the innermost containing scope. If variables are undefined, they are assumed to have global scope (they may come from the surrounding program).</p><h1 id="Tensor-Lifecycle"><a class="docs-heading-anchor" href="#Tensor-Lifecycle">Tensor Lifecycle</a><a id="Tensor-Lifecycle-1"></a><a class="docs-heading-anchor-permalink" href="#Tensor-Lifecycle" title="Permalink"></a></h1><p>Tensors have two modes: Read and Update. Tensors in read mode may be read, but not updated. Tensors in update mode may be updated, but not read. A tensor declaration initializes and possibly resizes the tensor, setting it to update mode. Also, Finch will automatically change the mode of tensors as they are used. However, tensors may only change their mode within scopes that contain their declaration. If a tensor has not been declared, it is assumed to have global scope.</p><p>Tensor declaration is different than variable definition. Declaring a tensor initializes the memory (usually to zero) and sets the tensor to update mode. Defining a tensor simply gives a name to that memory. A tensor may be declared multiple times, but it may only be defined once.</p><p>Tensors are assumed to be in read mode when they are defined.  Tensors must enter and exit scope in read mode. Finch inserts <code>freeze</code> and <code>thaw</code> statements to ensure that tensors are in the correct mode. Freezing a tensor prevents further updates and allows reads. Thawing a tensor allows further updates and prevents reads.</p><p>Tensor lifecycle statements consist of:</p><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.declare" href="#Finch.FinchNotation.declare"><code>Finch.FinchNotation.declare</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">declare(tns, init)</code></pre><p>Finch AST statement that declares <code>tns</code> with an initial value <code>init</code> in the current scope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/a03c0cb8a2833ac998f963a52edd2432f8e4e0b7/src/FinchNotation/nodes.jl#L133-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.freeze" href="#Finch.FinchNotation.freeze"><code>Finch.FinchNotation.freeze</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">freeze(tns)</code></pre><p>Finch AST statement that freezes <code>tns</code> in the current scope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/a03c0cb8a2833ac998f963a52edd2432f8e4e0b7/src/FinchNotation/nodes.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Finch.FinchNotation.thaw" href="#Finch.FinchNotation.thaw"><code>Finch.FinchNotation.thaw</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">thaw(tns)</code></pre><p>Finch AST statement that thaws <code>tns</code> in the current scope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/willow-ahrens/Finch.jl/blob/a03c0cb8a2833ac998f963a52edd2432f8e4e0b7/src/FinchNotation/nodes.jl#L147-L151">source</a></section></article><h1 id="Dimensionalization"><a class="docs-heading-anchor" href="#Dimensionalization">Dimensionalization</a><a id="Dimensionalization-1"></a><a class="docs-heading-anchor-permalink" href="#Dimensionalization" title="Permalink"></a></h1><p>Finch loops have dimensions. Accessing a tensor with an unmodified loop index &quot;hints&quot; that the loop should have the same dimension as the corresponding axis of the tensor. Finch will automatically dimensionalize loops that are hinted by tensor accesses. One may refer to the automatically determined dimension using a variable named <code>_</code> or <code>:</code>. </p><p>Similarly, tensor declarations also set the dimensions of a tensor. Accessing a tensor with an unmodified loop index &quot;hints&quot; that the tensor axis should have the same dimension as the corresponding loop. Finch will automatically dimensionalize declarations based on all updates up to the first read.  </p><h1 id="Array-Combinators"><a class="docs-heading-anchor" href="#Array-Combinators">Array Combinators</a><a id="Array-Combinators-1"></a><a class="docs-heading-anchor-permalink" href="#Array-Combinators" title="Permalink"></a></h1><p>Finch includes several array combinators that modify the behavior of arrays. For example, the <code>OffsetArray</code> type wraps an existing array, but shifts its indices. The <code>PermissiveArray</code> type wraps an existing array, but allows out-of-bounds reads and writes. When an array is accessed out of bounds, it produces <code>Missing</code>.</p><p>Array combinators introduce some complexity to the tensor lifecycle, as wrappers may contain multiple or different arrays that could potentially be in different modes. Any array combinators used in a tensor access must reference a single global variable which holds the root array. The root array is the single array that gets declared, and changes modes from read to update, or vice versa.</p><h1 id="Fancy-Indexing"><a class="docs-heading-anchor" href="#Fancy-Indexing">Fancy Indexing</a><a id="Fancy-Indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Fancy-Indexing" title="Permalink"></a></h1><p>Finch supports arbitrary indexing of arrays, but certain indexing operations have first class support through array combinators. Before dimensionalization, the following transformations are performed:</p><pre><code class="nohighlight hljs">    A[i + c] =&gt;        OffsetArray(A, c)[i]
    A[i + j] =&gt;      ToeplitzArray(A, 1)[i, j]
       A[~i] =&gt; PermissiveArray(A, true)[i]</code></pre><p>Note that these transformations may change the behavior of dimensionalization, since they often result in unmodified loop indices (the index <code>i</code> will participate in dimensionalization, but an index expression like <code>i + 1</code> will not).</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../usage/">« Usage</a><a class="docs-footer-nextpage" href="../fibers/">Array Formats »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 17 August 2023 15:24">Thursday 17 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
